{
    "docs": [
        {
            "location": "/",
            "text": "Sduino\n\n\nPorting the most important features of the Arduino API to the STM8S.\n\n\nWithin a few minutes you are ready to compile and upload your first\nSTM8S-based project while still retaining the flexibility to use ST's SPL\nfunctions.\n\n\nAll you need to get started is a simple STM8S103F breakout board for 70\ncents and a ST-Link V2 compatible flash programmer for $2.50. Three boards\nand one flash programmer together are available for well under five dollars\nincluding shipping on \naliexpress\n.\n\n\nAmazing!\n\n\nUsage\n\n\nIf you have ever used the Arduino environment before you will feel at home\nright away, despite this project beeing based on a makefile rather than the\nfull Arduino IDE. But don't be afraid, it is based on the amazing\n\nArduino.mk makefile\n by\n\nSudar\n to control the build process, that makes\neverything very easy.\n\n\nLet's blink an LED using the Blink example from Arduino:\n\n\n/*\n  Blink\n  Turns on an LED on for one second, then off for one second, repeatedly.\n\n  This example code is in the public domain.\n*/\n\n#include <Arduino.h>\n\n// Pin 13 has an LED connected on most Arduino boards.\n// Pin 3 for the STM8S103 break out board\n// give it a name:\nint led = LED_BUILDIN;\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // initialize the digital pin as an output.\n  pinMode(led, OUTPUT);\n}\n\n// the loop routine runs over and over again forever:\nvoid loop() {\n  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)\n  delay(1000);               // wait for a second\n  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW\n  delay(1000);               // wait for a second\n}\n\n\n\n\nAll we need for a full build is this very basic \nMakefile\n:\n\n\nBOARD_TAG   = stm8sblue\n\ninclude ../../sduino/sduino.mk\n\n\n\n\nCompile and upload it:\n\n\nmake upload\n\n\n\nDone! Your first STM8 based project is up and running!\n\n\nTools used\n\n\nThis project is based on free tools that are available for Linux, MacOS, and\nWindows. \nInstallation instructions\n\n\nIt uses the small devices C compiler (SDCC) for compiling,\n\nstm8flash\n for uploading the binary\nto the CPU, and simple Makefiles for the build process.\n\n\nMore information on using SDCC\n\n\nSupport for the Cosmic compiler under Windows and integration into the ST\nvisual developer IDE might be possible, but is not done (yet?).\n\n\nThe build process is controlled by a makefile based on the amazing\n\nArduino.mk makefile\n by\n\nSudar\n.\n\n\nSupported hardware\n\n\n\n\n\n\nThe \none-dollar-boards\n: A simple STM8S103 breakout\n  board build around a CPU STM8S103F3P6. It costs less than a dollar. The\n  CPU features a 16MHz internal oscillator, 8kB flash, 1kB RAM, 640 byte\n  EEPROM. It includes an UART, SPI, I2C, PWM, 10 bit ADC, 3 timer, and up to\n  14 I/O pins - quite similar to an Atmel ATmega8.\n\n\n\n\n\n\nThe \nESP14 Wifi-boards\n are very similar. They are\n  basically a variant of these boards with an added ESP-01 Wifi-module. Almost\n  all programs should run on those chinese Wifi-enabled gems as well.\n\n\n\n\n\n\nThe \nSTM8S105Discovery-boards\n are very similar\n  to an Arduino Uno with an ATmega328 CPU. The support for the used STM8S105\n  CPU is still quite fresh but it should work now.\n\n\n\n\n\n\nCompatibility with the Arduino world\n\n\nI adopted the Arduino core functionality for the STM8S to set up a simple\nprogramming environment. But unfortunatly there is no free C++ compiler\nfor these CPUs. This makes it impossible to do a full port of the whole\nenviroment and integrate it with the Arduino IDE and build system as is\nhas been done for the STM32 and the ESP8266.\n\n\nThis is not a drop-in replacement for an AVR, but the programming API is\nstill very, very similar. Adopting existing libraries from C++ to C for use\nwith the simplified C API is often easy and can be done quite fast,\ndepending on the degree of dependency on specific hardware features.\n\n\nThe whole Arduino build system is deeply based on the assumption of\nprocessing C++ source files. I am not sure if it would be even possible to\nconfigure a build process based only on C files without modifing the IDE\nsources. This makes a full IDE integration very unlikely.\n\n\nUsing a converter/compiler like\n\ncfront\n to translate from C++ to C\nmight be an option.\n\n\nIncluded libraries\n\n\nSome Arduino libraries are already ported to C-syntax. The resulting API is\nstill very close to the C++ version and porting an existing application is\nnot hard. Check out the \nAPI migration guidelines\n for details.\n\n\nCommunication\n\n\n\n\nSPI\n: Real hardware-SPI up to 10MHz.\n\n\nI2C\n: Port of the I2C master library by Wayne Truchsess\n\n\nHardwareSerial: The standard serial interface.\n\n\n\n\nDisplays\n\n\n\n\nLiquidCrystal\n: HD44780 based text LCDs\n\n\nPCD8544\n: Monochrome graphical LCD based on the PCD8544\n  controller like the Nokia 5110 display. SPI mode only.\n\n\nMini_SSD1306\n: SSD1306-based monochrome OLED displays\n  with 128x64 pixels. I2C support only.\n\n\n\n\nMotor control\n\n\n\n\nStepper\n: Stepper motors with 2, 4 or 5 phases.\n\n\nServo\n: Up to 12 servos using only 1 timer.\n\n\n\n\nFloat arithmetics\n\n\nFloating point arithmetics is supported by the SDCC standard library, but it\ncomes at a pretty high cost in terms of code space and CPU load. This is how\nmuch the generated code grows by using a single float operation compared to \nusing a long int:\n\n\n\n\n\n\n\n\nFloating point operation\n\n\napprox. code size\n\n\n\n\n\n\n\n\n\n\naddition\n\n\n736 Bytes\n\n\n\n\n\n\nsubtraction\n\n\n754 Bytes\n\n\n\n\n\n\ndivision\n\n\n673 Bytes\n\n\n\n\n\n\nmultiplication\n\n\n907 Bytes\n\n\n\n\n\n\nsinf() or cosf()\n\n\n3346 Bytes\n\n\n\n\n\n\nlog10f()\n\n\n3437 Bytes\n\n\n\n\n\n\n\n\nThe Arduino standard example '01. Basics/ReadAnalogVoltage' is a very simple\nsimple program with only very little floating point arithmetics. But it\nalready uses 7336 bytes of flash. A similar sketch using integer arithmetics\nresults in much more compact code occuping only 3791 bytes.\n\n\nFloat does work, but is better to be avoided and replaced by fixed point\narithmetics whenever possible.\n\n\nCurrent status and to-do list\n\n\ntested and working\n\n\npinMode()\n\n\ndigitalWrite()\n\n\nanalogRead()\n\n\ndelay()\n\n\nanalogWrite()\n\n\nShiftOut()\n\nWMath: \nmap()\n\nHardwareSerial\n\nPrint\n\n\npulseInLong()\n\n\nSPI\n:\n  working, no interrupt support\n\n\nLiquidCrystal\n:\n  Text LCD based on the HD44780 controller\n\n\nPCD8544\n:\n  Nokia 5110 type displays\n\n\nMini_SSD1306\n:\n  Monochrome OLED displays based on the SSD1306 controller\n\nStepper\n:\n  Multi-instance design for more than one stepper at a time\n\n\nServo\n:\n  Multi-instance design for more than one servo at a time)  \n\n\nimplemented and partly working\n\n\nWire/I2C  \n\n\ntested, but not working\n\n\nalternateFunctions()\n  \n\n\nnot tested\n\n\nShiftIn()\n\n\nrandom()\n\n\nsrandom()\n  \n\n\nnot implemented\n\n\ntone()\n\n\nnoTone()\n\n\npulseIn()\n\nmodule WCharacter\n\nmodule WString  \n\n\nUnresolved problems\n\n\nThe compile environment needs to detect which interrupts are actively used\nand link only the needed ones into the binary. See test/digitalWrite:\nCompiling with the straight Makefile.classic does not add UART interrupt\nroutines. But when using the sduino.mk Makefile the two UART interrupt\nroutines are pulled into the binary by the interrupt table in main.c.\n\n\nWhy use a STM8 instead of an ATmega?\n\n\nThe fairly new ESP-14 module includes a STM8S003F3P6. Wifi and a\nprogrammable I/O-CPU for just over two dollars - that might be the most\ncompelling reason to get started on the STM8S series. Apart from pure\ncuriosity and eagerness to learn something new, of course.\n\n\nThe simple STM8S103F breakout boards are powerful and dirt cheap. They cost\nwell under one dollar. You can get three boards and one flash programmer\ntogether for well under five dollars on http://www.aliexpress.com/ ,\nincluding shipping from China.\n\n\nThe major downside of this CPU series is the lack of information and\ncommunity support for the STM8. The community support and the sheer number\nof existing libraries for all kinds of sensors and hardware is outstanding\nin the Arduino world. If you just want to get something done, go for an\nArduino board. Nothing will give you faster and easier results.\n\n\nFor commercial use the STM8S offers some interesting advantages:\n\n\nMotor control\n: The STM8 has a strong focus on motor and position control\nsystems. Things you need to handle yourself on an ATmega are implemented in\nhardware and work independently of the state of the software. There is even\nhardware support for quadrature encoders as used in position sensors and\nrotary encoders.\n\n\nLow power modes\n: The numbers in the datasheets don't look that different,\nbut in real life the STM8 can be powered two or three times longer using the\nsame battery capacity due to the finer control on the power modes (very,\nvery careful programming required).\n\n\nValue for the money\n: 40 to 60 cents for a STM8 with 14 I/O pins compared to\n$1.60-$3.00 for an ATmega8.\n\n\nUpgrade path\n: The peripheral units of the STM8 are identical or at least\nvery, very similar to the ones used with the STM32 family of 32 bit\nARM-Cortex CPUs. This makes it is relatively easy to migrate existing\nsoftware between the 8- and the 32-bit world. This is quite unique among the\nother CPUs.\n\n\nFurther reading and application notes\n\n\nproject documentation files\n\nMore in detail information about supported boards, tools and the API.\n\n\n[Quick introduction to the Arduino.mk makefile]\n(http://hackaday.com/2015/10/01/arduino-development-theres-a-makefile-for-that/)\n\n\nPM0051\n:\nSTM8AF Flash programming manual\n\n\nUM0470\n:\nSTM8 SWIM protocol and debug manual\n\n\nAN2658\n:\nUsing the analog-to-digital converter of the STM8S microcontroller  \n\n\nMany examples and presentations about the STM8S:\n\nhttps://github.com/VincentYChen/STM8teach\n\nIt contains the SPL examples from ST, the most useful resource on the STM8:\n\nhttps://github.com/VincentYChen/STM8teach/tree/master/code/Project/STM8S_StdPeriph_Examples\n\n\nHardware and pinouts of several ST-Link compatible flash tools:\nhttps://wiki.cuvoodoo.info/doku.php?id=jtag\n\n\nUsing the ADC:\n\nhttp://blog.mark-stevens.co.uk/2012/09/single-scan-adc-on-the-stm8s/  \n\n\nExample for RS-232 handling with SPL:\n\nhttps://sourceforge.net/p/oggstreamer/oggs-stm8-firmware-001/ci/master/tree/rx_ringbuffer.c  \n\n\nAN3139\n:\nMigration guideline within the STM8L familiy  \n\n\nModifications for the sdcc example programs\n\n\nblinky.c: LED pin assignment\n\n\nuart.c\n:  pin assignment (TX is at PD5, RX is at PD6).\n\nThe UART is sending at 1200 Baud => CPU clock only 2MHz instead of 16MHz.\nThe clock divider needs to be configured or a different baud rate prescale value\nhas to be used. Pitfall: The register address for the clock divider is\ndifferent for the STM8S and the STM8L.\n\n\nPerformance compared with the original Arduino environment\n\n\nBenchmarking the original Arduino examples from Arduino 1.0.5. The simple\nBlinky compiles to 57 bytes of code, the total binary including the sduino\nlibraries is 1868 Bytes (0x74c).\n\n\nSo far, wiring_analog depends on wiring_digital, even when analogWrite is not\nused. This could be solved by compiling the sduino functions separately into\na library.\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nTotal\n\n\nLinked files other than main and wiring\n\n\n\n\n\n\n\n\n\n\n01. Basics/\n\n\n\n\n\n\n\n\n\n\n\n\nBareMinimum\n\n\n2\n\n\n1238\n\n\n-\n\n\n\n\n\n\nBlink\n\n\n57\n\n\n1870\n\n\nwiring_digital\n\n\n\n\n\n\nAnalogReadSerial\n\n\n205\n\n\n3452\n\n\ndigital, analog, serial, print\n\n\n\n\n\n\nDigitalReadSerial\n\n\n57\n\n\n3160\n\n\ndigital, serial, print\n\n\n\n\n\n\nFade\n\n\n226\n\n\n2189\n\n\ndigital, analog\n\n\n\n\n\n\nReadAnalogVoltage\n\n\n\n\n\n\nfloat not yet implemented\n\n\n\n\n\n\n02. Digital/\n\n\n\n\n\n\n\n\n\n\n\n\nDebounce\n\n\n192\n\n\n2016\n\n\ndigital",
            "title": "Overview"
        },
        {
            "location": "/#sduino",
            "text": "Porting the most important features of the Arduino API to the STM8S.  Within a few minutes you are ready to compile and upload your first\nSTM8S-based project while still retaining the flexibility to use ST's SPL\nfunctions.  All you need to get started is a simple STM8S103F breakout board for 70\ncents and a ST-Link V2 compatible flash programmer for $2.50. Three boards\nand one flash programmer together are available for well under five dollars\nincluding shipping on  aliexpress .  Amazing!",
            "title": "Sduino"
        },
        {
            "location": "/#usage",
            "text": "If you have ever used the Arduino environment before you will feel at home\nright away, despite this project beeing based on a makefile rather than the\nfull Arduino IDE. But don't be afraid, it is based on the amazing Arduino.mk makefile  by Sudar  to control the build process, that makes\neverything very easy.  Let's blink an LED using the Blink example from Arduino:  /*\n  Blink\n  Turns on an LED on for one second, then off for one second, repeatedly.\n\n  This example code is in the public domain.\n*/\n\n#include <Arduino.h>\n\n// Pin 13 has an LED connected on most Arduino boards.\n// Pin 3 for the STM8S103 break out board\n// give it a name:\nint led = LED_BUILDIN;\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // initialize the digital pin as an output.\n  pinMode(led, OUTPUT);\n}\n\n// the loop routine runs over and over again forever:\nvoid loop() {\n  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)\n  delay(1000);               // wait for a second\n  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW\n  delay(1000);               // wait for a second\n}  All we need for a full build is this very basic  Makefile :  BOARD_TAG   = stm8sblue\n\ninclude ../../sduino/sduino.mk  Compile and upload it:  make upload  Done! Your first STM8 based project is up and running!",
            "title": "Usage"
        },
        {
            "location": "/#tools-used",
            "text": "This project is based on free tools that are available for Linux, MacOS, and\nWindows.  Installation instructions  It uses the small devices C compiler (SDCC) for compiling, stm8flash  for uploading the binary\nto the CPU, and simple Makefiles for the build process.  More information on using SDCC  Support for the Cosmic compiler under Windows and integration into the ST\nvisual developer IDE might be possible, but is not done (yet?).  The build process is controlled by a makefile based on the amazing Arduino.mk makefile  by Sudar .",
            "title": "Tools used"
        },
        {
            "location": "/#supported-hardware",
            "text": "The  one-dollar-boards : A simple STM8S103 breakout\n  board build around a CPU STM8S103F3P6. It costs less than a dollar. The\n  CPU features a 16MHz internal oscillator, 8kB flash, 1kB RAM, 640 byte\n  EEPROM. It includes an UART, SPI, I2C, PWM, 10 bit ADC, 3 timer, and up to\n  14 I/O pins - quite similar to an Atmel ATmega8.    The  ESP14 Wifi-boards  are very similar. They are\n  basically a variant of these boards with an added ESP-01 Wifi-module. Almost\n  all programs should run on those chinese Wifi-enabled gems as well.    The  STM8S105Discovery-boards  are very similar\n  to an Arduino Uno with an ATmega328 CPU. The support for the used STM8S105\n  CPU is still quite fresh but it should work now.",
            "title": "Supported hardware"
        },
        {
            "location": "/#compatibility-with-the-arduino-world",
            "text": "I adopted the Arduino core functionality for the STM8S to set up a simple\nprogramming environment. But unfortunatly there is no free C++ compiler\nfor these CPUs. This makes it impossible to do a full port of the whole\nenviroment and integrate it with the Arduino IDE and build system as is\nhas been done for the STM32 and the ESP8266.  This is not a drop-in replacement for an AVR, but the programming API is\nstill very, very similar. Adopting existing libraries from C++ to C for use\nwith the simplified C API is often easy and can be done quite fast,\ndepending on the degree of dependency on specific hardware features.  The whole Arduino build system is deeply based on the assumption of\nprocessing C++ source files. I am not sure if it would be even possible to\nconfigure a build process based only on C files without modifing the IDE\nsources. This makes a full IDE integration very unlikely.  Using a converter/compiler like cfront  to translate from C++ to C\nmight be an option.",
            "title": "Compatibility with the Arduino world"
        },
        {
            "location": "/#included-libraries",
            "text": "Some Arduino libraries are already ported to C-syntax. The resulting API is\nstill very close to the C++ version and porting an existing application is\nnot hard. Check out the  API migration guidelines  for details.  Communication   SPI : Real hardware-SPI up to 10MHz.  I2C : Port of the I2C master library by Wayne Truchsess  HardwareSerial: The standard serial interface.   Displays   LiquidCrystal : HD44780 based text LCDs  PCD8544 : Monochrome graphical LCD based on the PCD8544\n  controller like the Nokia 5110 display. SPI mode only.  Mini_SSD1306 : SSD1306-based monochrome OLED displays\n  with 128x64 pixels. I2C support only.   Motor control   Stepper : Stepper motors with 2, 4 or 5 phases.  Servo : Up to 12 servos using only 1 timer.",
            "title": "Included libraries"
        },
        {
            "location": "/#float-arithmetics",
            "text": "Floating point arithmetics is supported by the SDCC standard library, but it\ncomes at a pretty high cost in terms of code space and CPU load. This is how\nmuch the generated code grows by using a single float operation compared to \nusing a long int:     Floating point operation  approx. code size      addition  736 Bytes    subtraction  754 Bytes    division  673 Bytes    multiplication  907 Bytes    sinf() or cosf()  3346 Bytes    log10f()  3437 Bytes     The Arduino standard example '01. Basics/ReadAnalogVoltage' is a very simple\nsimple program with only very little floating point arithmetics. But it\nalready uses 7336 bytes of flash. A similar sketch using integer arithmetics\nresults in much more compact code occuping only 3791 bytes.  Float does work, but is better to be avoided and replaced by fixed point\narithmetics whenever possible.",
            "title": "Float arithmetics"
        },
        {
            "location": "/#current-status-and-to-do-list",
            "text": "tested and working  pinMode()  digitalWrite()  analogRead()  delay()  analogWrite()  ShiftOut() \nWMath:  map() \nHardwareSerial \nPrint  pulseInLong()  SPI :\n  working, no interrupt support  LiquidCrystal :\n  Text LCD based on the HD44780 controller  PCD8544 :\n  Nokia 5110 type displays  Mini_SSD1306 :\n  Monochrome OLED displays based on the SSD1306 controller Stepper :\n  Multi-instance design for more than one stepper at a time  Servo :\n  Multi-instance design for more than one servo at a time)    implemented and partly working  Wire/I2C    tested, but not working  alternateFunctions()     not tested  ShiftIn()  random()  srandom()     not implemented  tone()  noTone()  pulseIn() \nmodule WCharacter \nmodule WString    Unresolved problems  The compile environment needs to detect which interrupts are actively used\nand link only the needed ones into the binary. See test/digitalWrite:\nCompiling with the straight Makefile.classic does not add UART interrupt\nroutines. But when using the sduino.mk Makefile the two UART interrupt\nroutines are pulled into the binary by the interrupt table in main.c.",
            "title": "Current status and to-do list"
        },
        {
            "location": "/#why-use-a-stm8-instead-of-an-atmega",
            "text": "The fairly new ESP-14 module includes a STM8S003F3P6. Wifi and a\nprogrammable I/O-CPU for just over two dollars - that might be the most\ncompelling reason to get started on the STM8S series. Apart from pure\ncuriosity and eagerness to learn something new, of course.  The simple STM8S103F breakout boards are powerful and dirt cheap. They cost\nwell under one dollar. You can get three boards and one flash programmer\ntogether for well under five dollars on http://www.aliexpress.com/ ,\nincluding shipping from China.  The major downside of this CPU series is the lack of information and\ncommunity support for the STM8. The community support and the sheer number\nof existing libraries for all kinds of sensors and hardware is outstanding\nin the Arduino world. If you just want to get something done, go for an\nArduino board. Nothing will give you faster and easier results.  For commercial use the STM8S offers some interesting advantages:  Motor control : The STM8 has a strong focus on motor and position control\nsystems. Things you need to handle yourself on an ATmega are implemented in\nhardware and work independently of the state of the software. There is even\nhardware support for quadrature encoders as used in position sensors and\nrotary encoders.  Low power modes : The numbers in the datasheets don't look that different,\nbut in real life the STM8 can be powered two or three times longer using the\nsame battery capacity due to the finer control on the power modes (very,\nvery careful programming required).  Value for the money : 40 to 60 cents for a STM8 with 14 I/O pins compared to\n$1.60-$3.00 for an ATmega8.  Upgrade path : The peripheral units of the STM8 are identical or at least\nvery, very similar to the ones used with the STM32 family of 32 bit\nARM-Cortex CPUs. This makes it is relatively easy to migrate existing\nsoftware between the 8- and the 32-bit world. This is quite unique among the\nother CPUs.",
            "title": "Why use a STM8 instead of an ATmega?"
        },
        {
            "location": "/#further-reading-and-application-notes",
            "text": "project documentation files \nMore in detail information about supported boards, tools and the API.  [Quick introduction to the Arduino.mk makefile]\n(http://hackaday.com/2015/10/01/arduino-development-theres-a-makefile-for-that/)  PM0051 :\nSTM8AF Flash programming manual  UM0470 :\nSTM8 SWIM protocol and debug manual  AN2658 :\nUsing the analog-to-digital converter of the STM8S microcontroller    Many examples and presentations about the STM8S: \nhttps://github.com/VincentYChen/STM8teach \nIt contains the SPL examples from ST, the most useful resource on the STM8: \nhttps://github.com/VincentYChen/STM8teach/tree/master/code/Project/STM8S_StdPeriph_Examples  Hardware and pinouts of several ST-Link compatible flash tools:\nhttps://wiki.cuvoodoo.info/doku.php?id=jtag  Using the ADC: \nhttp://blog.mark-stevens.co.uk/2012/09/single-scan-adc-on-the-stm8s/    Example for RS-232 handling with SPL: \nhttps://sourceforge.net/p/oggstreamer/oggs-stm8-firmware-001/ci/master/tree/rx_ringbuffer.c    AN3139 :\nMigration guideline within the STM8L familiy",
            "title": "Further reading and application notes"
        },
        {
            "location": "/#modifications-for-the-sdcc-example-programs",
            "text": "blinky.c: LED pin assignment  uart.c :  pin assignment (TX is at PD5, RX is at PD6). \nThe UART is sending at 1200 Baud => CPU clock only 2MHz instead of 16MHz.\nThe clock divider needs to be configured or a different baud rate prescale value\nhas to be used. Pitfall: The register address for the clock divider is\ndifferent for the STM8S and the STM8L.  Performance compared with the original Arduino environment  Benchmarking the original Arduino examples from Arduino 1.0.5. The simple\nBlinky compiles to 57 bytes of code, the total binary including the sduino\nlibraries is 1868 Bytes (0x74c).  So far, wiring_analog depends on wiring_digital, even when analogWrite is not\nused. This could be solved by compiling the sduino functions separately into\na library.     Name  Code  Total  Linked files other than main and wiring      01. Basics/       BareMinimum  2  1238  -    Blink  57  1870  wiring_digital    AnalogReadSerial  205  3452  digital, analog, serial, print    DigitalReadSerial  57  3160  digital, serial, print    Fade  226  2189  digital, analog    ReadAnalogVoltage    float not yet implemented    02. Digital/       Debounce  192  2016  digital",
            "title": "Modifications for the sdcc example programs"
        },
        {
            "location": "/install/",
            "text": "Installing the needed tools\n\n\nAll tools are available for Linux, MacOS and Windows, most of them even for\nRaspbian on a RaspberryPi.\n\n\nSDCC support for the STM8 is still quite fresh and not very mature. It\nimproves significantly from version to version. Be sure to use\n\nthe latest snapshot build\n from the\n\nproject site on sourceforge\n, not the older\nversion that might be included in your distribution.\n\n\nLinux\n\n\nDownload the lastest snapshot build for SDCC from\nhttp://sdcc.sourceforge.net/snap.php and extract it under \n/opt\n.\n\n\nmkdir /opt\ntar xvjf ~/Downloads/sdcc-snapshot* -C /opt\n\n\n\nmake\n is part of the standard repository for any Linux distribution.\nExample for Debian-type systems (like Ubuntu, Mint, Elementary etc.):\n\n\napt-get install make\n\n\n\nstm8flash\n is included in the tools directory of this repository. Copy it\nto a convient place in your path, e.g. \n/usr/local/bin\n. To use it you might\nneed to add a udev rule in order to access the USB port. Save this as root\nin in \n/etc/udev/rules.d/99-stlink.rules\n:\n\n\n# ST-Link/V2 programming adapter\n\n# ST-Link V1, if using a STM8S discovery board\n# important: It needs a special entry in /etc/modprob/blacklist\nATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3744\", MODE=\"0666\", GROUP=\"plugdev\"\n\n# ST-Link/V2, the china adapter with the green plastic housing\nATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\", GROUP=\"plugdev\"\n\n\n\nMacOS\n\n\nQuite similar. \nInstall Homebrew\n if you haven't done it\nyet, than:\n\n\nbrew make\nmkdir /opt\ntar xvjf sdcc-snapshot* -C /opt\n\n\n\nNot sure about stm8flash, I didn't try it. Have a look at the\n\nstm8flash repository\n.\n\n\nWindows\n\n\nHarder, but still possible. It is lacking all the tools, a package system to\ninstall them and even a file system concept where to store them. For\nconvinience, I collected the bare minimum of needed tools in a\n\nseparate repository\n.\nDownload it and copy the directory tree into the sduino\ndirectory. Add the sduino/tools/bin directory to your path or move the files\nin there to a directory that is already in your path.\n\n\nYou are not bound to \nstm8flash\n, you can use the regular flash tool by ST\nas well.\n\n\nThe individual pieces\n\n\nAll the tools in the convinience package are 32 bit. If you need the 64 bit\nversions you might have to collect them yourself.\n\n\nYou need SDCC, \nmake\n with some basic tools and maybe \nstm8flash\n. Get SDCC\nfrom the project website. \nmake\n is a standard tool included in either\nMinGW/Msys or cygwin. Both are fine, MinGW/Msys is smaller. \nstm8flash\n from\nthe \nstm8flash repository\n.\n\n\nSDCC\n\n\n\n\nDownload the lastest snapshot build from http://sdcc.sourceforge.net/snap.php\n\n\nunzip into c:\\sdcc (use a path name without whitespace)\n\n\n\n\nYou only need support for the stm8. You can safely delete all the files\nrelated to the pic1x CPUs (that safes more than 90% of the used disk space\nand leaves only 20MB out of 240MB)\n\n\nMinGW\n\n\nMinGW/MSys\n and\n\ncygwin\n are both fine. cygwin aims to be an almost\ncomplete POSIX environment (which is nice, but we don't need it here). MinGW\nwants to be more compact and works with the native Windows API. That is good\nenough for this purpose.\n\n\n\n\nCheck the\n  \nMinGW Installation Notes\n\n\nDownload\n  \nmingw-get-setup.exe\n\n  from https://sourceforge.net/projects/mingw/files/Installer/\n\n\nStart it. You can safely deactivate the graphical option.\n\n\nAdd this at the end to your path: \n;c:\\mingw\\bin;c:\\mingw\\msys\\1.0\\bin\n\n  (follow the instructions in \"Environment Setting\" on the [Installation\n  Notes page[(http://www.mingw.org/wiki/Getting_Started))\n\n\nOpen a command line and install the package msys-base by issuing this\n  command: \nmingw-get install msys-base\n\n\nNow \nls\n or \nmake\n should work.\n\n\n\n\nFor efficiency, the Makefile is configured to use dash instead of bash as a\nshell. \negrep\n is replaced by \ngrep -E\n. The bare minimum of tools you will\nneed to run the Arduino.mk makefile:\n\n\ndash make\nawk cat cut expr grep head ls mkdir sed tr uname which\n\n\n\nstm8flash\n\n\nA precompiled windows binary was in the stm8flash repository for a while but\ngot removed at one point. I used an\n\nold version\n\nof the file. You might prefer to compile your own version from the\n\nstm8flash repository\n using either\nMinGW or cygwin. For compiling, you will need the libusb windows binary:\nhttp://libusb.info/ (I used the MinGW32 dll)\n\n\nGeneral problems using Windows\n\n\nIt works, but using the Arduino.mk makefile with Windows is slow. \nVery\n\nslow. Painfully slow. Compiling-the-Blink-example-takes-about-40-seconds\nkind of slow. Yes, seriously. No kidding. 40 seconds. Measured on a 3GHz\nmachine with 4GB RAM.\n\n\nThere is no easy fix, the underlying problem is a fundamental one. It is not\nabout the compilation itself, it is the way Makefiles are written and\nexecuted. The whole concept relies on forking subprocesses for all the shell\ncalls. Unfortunately, there is nothing like a fork in Windows and to work\naround that is painfully slow.\n\n\nIt would be great if somebody could manage to modify the original Arduino\nbuild system to support non-C++-builds. Or to integrate it somehow into the\nSTVD IDE. Or replace the painfully slow parameter checking part of the\nmakefile (that causes the majority of forking) by a single shell script that\ngets called by the makefile and delivers the results in no time. Or use\n\ncmake\n. Or whatever.\n\n\nUntil than the least annoying way out might be using a virtual machine\nrunning a simple Linux system. Ubuntu Mate or a basic Debian install for\nexample. Virtual Box is great for this purpose and freely available.\n\n\nPossible improvements\n\n\nAll-inclusive packages\n\n\nOne of the big convinience points of the Arduino project are the\neasy-to-install all-inclusive packages without any external dependencies.\nThey don't require any prior knowledge to set up a full cross-compiler tool\nchain.\n\n\nSomething like that would be very nice for the STM8 as well, but I didn't go\nthat far. You still have to do some work yourself. You definitly need the\ncompiler SDCC. \nstm8flash\n is a simple tool to transfer the compiled program\nto the CPU, but any other flash tool supporting the SWIM protocol will do.\nThe build process is controlled by \nmake\n. It is a standard tool with any\nUNIX system but available for windows as well.\n\n\nAlternative ways of controlling the build process exist, but then you are\non your own to set it up.",
            "title": "Installation"
        },
        {
            "location": "/install/#installing-the-needed-tools",
            "text": "All tools are available for Linux, MacOS and Windows, most of them even for\nRaspbian on a RaspberryPi.  SDCC support for the STM8 is still quite fresh and not very mature. It\nimproves significantly from version to version. Be sure to use the latest snapshot build  from the project site on sourceforge , not the older\nversion that might be included in your distribution.",
            "title": "Installing the needed tools"
        },
        {
            "location": "/install/#linux",
            "text": "Download the lastest snapshot build for SDCC from\nhttp://sdcc.sourceforge.net/snap.php and extract it under  /opt .  mkdir /opt\ntar xvjf ~/Downloads/sdcc-snapshot* -C /opt  make  is part of the standard repository for any Linux distribution.\nExample for Debian-type systems (like Ubuntu, Mint, Elementary etc.):  apt-get install make  stm8flash  is included in the tools directory of this repository. Copy it\nto a convient place in your path, e.g.  /usr/local/bin . To use it you might\nneed to add a udev rule in order to access the USB port. Save this as root\nin in  /etc/udev/rules.d/99-stlink.rules :  # ST-Link/V2 programming adapter\n\n# ST-Link V1, if using a STM8S discovery board\n# important: It needs a special entry in /etc/modprob/blacklist\nATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3744\", MODE=\"0666\", GROUP=\"plugdev\"\n\n# ST-Link/V2, the china adapter with the green plastic housing\nATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\", GROUP=\"plugdev\"",
            "title": "Linux"
        },
        {
            "location": "/install/#macos",
            "text": "Quite similar.  Install Homebrew  if you haven't done it\nyet, than:  brew make\nmkdir /opt\ntar xvjf sdcc-snapshot* -C /opt  Not sure about stm8flash, I didn't try it. Have a look at the stm8flash repository .",
            "title": "MacOS"
        },
        {
            "location": "/install/#windows",
            "text": "Harder, but still possible. It is lacking all the tools, a package system to\ninstall them and even a file system concept where to store them. For\nconvinience, I collected the bare minimum of needed tools in a separate repository .\nDownload it and copy the directory tree into the sduino\ndirectory. Add the sduino/tools/bin directory to your path or move the files\nin there to a directory that is already in your path.  You are not bound to  stm8flash , you can use the regular flash tool by ST\nas well.  The individual pieces  All the tools in the convinience package are 32 bit. If you need the 64 bit\nversions you might have to collect them yourself.  You need SDCC,  make  with some basic tools and maybe  stm8flash . Get SDCC\nfrom the project website.  make  is a standard tool included in either\nMinGW/Msys or cygwin. Both are fine, MinGW/Msys is smaller.  stm8flash  from\nthe  stm8flash repository .  SDCC   Download the lastest snapshot build from http://sdcc.sourceforge.net/snap.php  unzip into c:\\sdcc (use a path name without whitespace)   You only need support for the stm8. You can safely delete all the files\nrelated to the pic1x CPUs (that safes more than 90% of the used disk space\nand leaves only 20MB out of 240MB)  MinGW  MinGW/MSys  and cygwin  are both fine. cygwin aims to be an almost\ncomplete POSIX environment (which is nice, but we don't need it here). MinGW\nwants to be more compact and works with the native Windows API. That is good\nenough for this purpose.   Check the\n   MinGW Installation Notes  Download\n   mingw-get-setup.exe \n  from https://sourceforge.net/projects/mingw/files/Installer/  Start it. You can safely deactivate the graphical option.  Add this at the end to your path:  ;c:\\mingw\\bin;c:\\mingw\\msys\\1.0\\bin \n  (follow the instructions in \"Environment Setting\" on the [Installation\n  Notes page[(http://www.mingw.org/wiki/Getting_Started))  Open a command line and install the package msys-base by issuing this\n  command:  mingw-get install msys-base  Now  ls  or  make  should work.   For efficiency, the Makefile is configured to use dash instead of bash as a\nshell.  egrep  is replaced by  grep -E . The bare minimum of tools you will\nneed to run the Arduino.mk makefile:  dash make\nawk cat cut expr grep head ls mkdir sed tr uname which  stm8flash  A precompiled windows binary was in the stm8flash repository for a while but\ngot removed at one point. I used an old version \nof the file. You might prefer to compile your own version from the stm8flash repository  using either\nMinGW or cygwin. For compiling, you will need the libusb windows binary:\nhttp://libusb.info/ (I used the MinGW32 dll)  General problems using Windows  It works, but using the Arduino.mk makefile with Windows is slow.  Very \nslow. Painfully slow. Compiling-the-Blink-example-takes-about-40-seconds\nkind of slow. Yes, seriously. No kidding. 40 seconds. Measured on a 3GHz\nmachine with 4GB RAM.  There is no easy fix, the underlying problem is a fundamental one. It is not\nabout the compilation itself, it is the way Makefiles are written and\nexecuted. The whole concept relies on forking subprocesses for all the shell\ncalls. Unfortunately, there is nothing like a fork in Windows and to work\naround that is painfully slow.  It would be great if somebody could manage to modify the original Arduino\nbuild system to support non-C++-builds. Or to integrate it somehow into the\nSTVD IDE. Or replace the painfully slow parameter checking part of the\nmakefile (that causes the majority of forking) by a single shell script that\ngets called by the makefile and delivers the results in no time. Or use cmake . Or whatever.  Until than the least annoying way out might be using a virtual machine\nrunning a simple Linux system. Ubuntu Mate or a basic Debian install for\nexample. Virtual Box is great for this purpose and freely available.",
            "title": "Windows"
        },
        {
            "location": "/install/#possible-improvements",
            "text": "All-inclusive packages  One of the big convinience points of the Arduino project are the\neasy-to-install all-inclusive packages without any external dependencies.\nThey don't require any prior knowledge to set up a full cross-compiler tool\nchain.  Something like that would be very nice for the STM8 as well, but I didn't go\nthat far. You still have to do some work yourself. You definitly need the\ncompiler SDCC.  stm8flash  is a simple tool to transfer the compiled program\nto the CPU, but any other flash tool supporting the SWIM protocol will do.\nThe build process is controlled by  make . It is a standard tool with any\nUNIX system but available for windows as well.  Alternative ways of controlling the build process exist, but then you are\non your own to set it up.",
            "title": "Possible improvements"
        },
        {
            "location": "/sdcc/",
            "text": "Compiler\n\n\nTutorials:\nhttp://www.cnx-software.com/2015/04/13/how-to-program-stm8s-1-board-in-linux/\n\n\nSTM8-Support only started with Version 3.4 in Ubuntu 14.10. For Ubuntu 14.4:\n\n\nadd-apt-repository ppa:laczik/ppa\napt-get update\napt-get install sdcc\n\n\n\nBut even this version is fairly old and contains some known bugs. Better\ndownload a current snapshot build from http://sdcc.sourceforge.net/ and\nunpack it to \n/opt/sdcc\n. This requires a current version of libstdc++6:\n\n\nadd-apt-repository ppa:ubuntu-toolchain-r/test\napt-get update\napt-get install libstdc++6\n\n\n\nIf you prefer to compile stm8flash yourself instead of using the Linux\nbinaries in the \ntools\n directory:\n\n\ngit clone https://github.com/vdudouyt/stm8flash.git\ncd stm8flash\nmake\nsudo make install\n\n\n\nDownload some example code:\n\n\ngit clone https://github.com/vdudouyt/sdcc-examples-stm8.git\ncd sdcc-examples-stm8\n\n\n\nThe examples are meant for the STM8L, not the STM8S. This requires some\nchanges to account for the different pinout and register addresses (see below).\nFinally upload the binary to the CPU:\n\n\nstm8flash -c stlinkv2 -p stm8s103?3 -w blinky.ihx\n\n\n\nMixing assembler code with C code\n\n\nc-code:\n\n\nstacktest(0x1234, 0x5678);\n\n\n\nassember:\n\n\npush    #0x78\npush    #0x56\npush    #0x34\npush    #0x12\ncall    _stacktest\n\n\n\nresulting stack content (starting at [SP], using simulator sstm8):\n\n\n0> dch 0x17f9\n0x017f9 c0 80 ab 12 34 56 78 5b ....4Vx[\n\n\n\n=> first paramter starts at [SP+3], MSB first.\n\n\nRegister assignment\n\n\nreturn values\n:\n8 bit values in A, 16 bit values in X, 32 bit values in Y/X (Y=MSB, X=LSB)\n\n\nregister preservation\n:\nNot implemented for the STM8 (yet?). For some architectures SDCC implements\nthe possibility to mark a function that it does not effect the contents of\nsome registers:\n\n\nvoid f(void) __preserves_regs(b, c, iyl, iyh);\n\n\n\nNotes on SDCC\n\n\nThe linker \nsdld\n does not automatically link the object file for main.c if it\nis part of a library. It must be part of the list of object files. (Important\nfor the build process with Arduino.mk)\n\n\nBefehl \n__critical{..}\n sollte eigentlich den vorherigen Interrupt-Zustand\nwiederherstellen, es wird aber einfach ein festes Paar sim/rim produziert.\nMit \"push cc; sim\" und \"pop cc\" klappt es im Simulator, aber nicht in der\nRealit\u00e4t.\n\n\nF\u00fcr jeden benutzten Interrupt \nmuss\n ein Prototyp in der Datei stehen, in\nder auch main() definiert ist. Aber f\u00fcr jeden Prototypen, f\u00fcr den es keine\nFunktion gibt, ergibt einen Linkerfehler. Das erkl\u00e4rt den Sinn von stm8s_it.h\nim Projektverzeichniss. Eine Arduino-\u00e4hnliche Umgebung muss diese Datei also\nnach Analyse aller Sourcen selber erzeugen.\n\n\nSimulator sstm8\n\n\nDoes not account for different cpu models (work in progress).\nbase address for UART1 is 0x5240, not 0x5230\nTX and RX interrupt vectors 0x804C and 0x8050.\n\n\nCompilieren: braucht libboost-graph:\nlibboost-graph1.54-dev - generic graph components and algorithms in C++\n\nlibboost-graph1.54.0 - generic graph components and algorithms in C++\n\nlibboost-graph1.55-dev - generic graph components and algorithms in C++\n\nlibboost-graph1.55.0 - generic graph components and algorithms in C++  \n\n\nMissing peephole optimisations\n\n\nDirectly connected sequences of 'addw x,#' and 'subw x,#' should be\ncombined into one operation.\n\n\nMultiplication by two is done by 'mul' instead of a bitshift. Important for\narray access.\n\n\nInterrupt routine preamble\n:\nWhy is there a 'clr a/div x,a' sequence?\n\n\nIndirect 16 bit access\n:\n'ldw x,#addr/ldw x,(x)' should be 'ldw x,[addr]'\n\n\nIndirect function call\n:\n'ldw x,#addr/ldw x,(x)/call (x)' should be 'call [addr]'\n\n\nExample (Interrupt routine calls a function from a jump table):\n\n\nstatic volatile voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS] = {\n    nothing,\n    nothing,\n};\n\nvoid TIM1_CAP_COM_IRQHandler(void) __interrupt(ITC_IRQ_TIM1_CAPCOM)\n{\n    intFunc[1]();\n}\n\n\n\n\n;   -----------------------------------------\n;    function TIM1_CAP_COM_IRQHandler\n;   -----------------------------------------\n_TIM1_CAP_COM_IRQHandler:\n    clr a\n    div x, a\n    ldw x, #_intFunc+2\n    ldw x, (x)\n    call    (x)\n    iret\n    .area CODE\n    .area INITIALIZER\n__xinit__intFunc:\n    .dw _nothing\n    .dw _nothing\n    .area CABS (ABS)\n\n\n\n\nMissing compiler features\n\n\n\n\n_ _preserves_regs() function attribute not supported\n\n\n_ \nattribute\n _((weak))\n\n\n_ _critical{} generates sim/rim instead of push cc,sim/pop cc\n\n\ndead code elimination: Does not recognize tables of const values. Using a\n  const table would still pull in the whole object file, even when all\n  accesses to the table have been eleminated by the optimizer. Only way out\n  is to use \n#define\n statements instead.",
            "title": "Using the SDCC compiler"
        },
        {
            "location": "/sdcc/#compiler",
            "text": "Tutorials:\nhttp://www.cnx-software.com/2015/04/13/how-to-program-stm8s-1-board-in-linux/  STM8-Support only started with Version 3.4 in Ubuntu 14.10. For Ubuntu 14.4:  add-apt-repository ppa:laczik/ppa\napt-get update\napt-get install sdcc  But even this version is fairly old and contains some known bugs. Better\ndownload a current snapshot build from http://sdcc.sourceforge.net/ and\nunpack it to  /opt/sdcc . This requires a current version of libstdc++6:  add-apt-repository ppa:ubuntu-toolchain-r/test\napt-get update\napt-get install libstdc++6  If you prefer to compile stm8flash yourself instead of using the Linux\nbinaries in the  tools  directory:  git clone https://github.com/vdudouyt/stm8flash.git\ncd stm8flash\nmake\nsudo make install  Download some example code:  git clone https://github.com/vdudouyt/sdcc-examples-stm8.git\ncd sdcc-examples-stm8  The examples are meant for the STM8L, not the STM8S. This requires some\nchanges to account for the different pinout and register addresses (see below).\nFinally upload the binary to the CPU:  stm8flash -c stlinkv2 -p stm8s103?3 -w blinky.ihx  Mixing assembler code with C code  c-code:  stacktest(0x1234, 0x5678);  assember:  push    #0x78\npush    #0x56\npush    #0x34\npush    #0x12\ncall    _stacktest  resulting stack content (starting at [SP], using simulator sstm8):  0> dch 0x17f9\n0x017f9 c0 80 ab 12 34 56 78 5b ....4Vx[  => first paramter starts at [SP+3], MSB first.  Register assignment  return values :\n8 bit values in A, 16 bit values in X, 32 bit values in Y/X (Y=MSB, X=LSB)  register preservation :\nNot implemented for the STM8 (yet?). For some architectures SDCC implements\nthe possibility to mark a function that it does not effect the contents of\nsome registers:  void f(void) __preserves_regs(b, c, iyl, iyh);  Notes on SDCC  The linker  sdld  does not automatically link the object file for main.c if it\nis part of a library. It must be part of the list of object files. (Important\nfor the build process with Arduino.mk)  Befehl  __critical{..}  sollte eigentlich den vorherigen Interrupt-Zustand\nwiederherstellen, es wird aber einfach ein festes Paar sim/rim produziert.\nMit \"push cc; sim\" und \"pop cc\" klappt es im Simulator, aber nicht in der\nRealit\u00e4t.  F\u00fcr jeden benutzten Interrupt  muss  ein Prototyp in der Datei stehen, in\nder auch main() definiert ist. Aber f\u00fcr jeden Prototypen, f\u00fcr den es keine\nFunktion gibt, ergibt einen Linkerfehler. Das erkl\u00e4rt den Sinn von stm8s_it.h\nim Projektverzeichniss. Eine Arduino-\u00e4hnliche Umgebung muss diese Datei also\nnach Analyse aller Sourcen selber erzeugen.  Simulator sstm8  Does not account for different cpu models (work in progress).\nbase address for UART1 is 0x5240, not 0x5230\nTX and RX interrupt vectors 0x804C and 0x8050.  Compilieren: braucht libboost-graph:\nlibboost-graph1.54-dev - generic graph components and algorithms in C++ \nlibboost-graph1.54.0 - generic graph components and algorithms in C++ \nlibboost-graph1.55-dev - generic graph components and algorithms in C++ \nlibboost-graph1.55.0 - generic graph components and algorithms in C++    Missing peephole optimisations  Directly connected sequences of 'addw x,#' and 'subw x,#' should be\ncombined into one operation.  Multiplication by two is done by 'mul' instead of a bitshift. Important for\narray access.  Interrupt routine preamble :\nWhy is there a 'clr a/div x,a' sequence?  Indirect 16 bit access :\n'ldw x,#addr/ldw x,(x)' should be 'ldw x,[addr]'  Indirect function call :\n'ldw x,#addr/ldw x,(x)/call (x)' should be 'call [addr]'  Example (Interrupt routine calls a function from a jump table):  static volatile voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS] = {\n    nothing,\n    nothing,\n};\n\nvoid TIM1_CAP_COM_IRQHandler(void) __interrupt(ITC_IRQ_TIM1_CAPCOM)\n{\n    intFunc[1]();\n}  ;   -----------------------------------------\n;    function TIM1_CAP_COM_IRQHandler\n;   -----------------------------------------\n_TIM1_CAP_COM_IRQHandler:\n    clr a\n    div x, a\n    ldw x, #_intFunc+2\n    ldw x, (x)\n    call    (x)\n    iret\n    .area CODE\n    .area INITIALIZER\n__xinit__intFunc:\n    .dw _nothing\n    .dw _nothing\n    .area CABS (ABS)  Missing compiler features   _ _preserves_regs() function attribute not supported  _  attribute  _((weak))  _ _critical{} generates sim/rim instead of push cc,sim/pop cc  dead code elimination: Does not recognize tables of const values. Using a\n  const table would still pull in the whole object file, even when all\n  accesses to the table have been eleminated by the optimizer. Only way out\n  is to use  #define  statements instead.",
            "title": "Compiler"
        },
        {
            "location": "/spl/",
            "text": "ST Standard Library\n\n\nCan be [downloaded from the ST website]\n(http://www.st.com/en/embedded-software/stsw-stm8069.html)\n(free registration required). Don't miss the Examples folder within the\ndownloaded zip file. This is the most useful reference on using this library\nand programming the STM8 in general.\n\n\nFor use with SDCC the library needs to be patched:\n\n\ngit clone https://github.com/g-gabber/STM8S_StdPeriph_Driver.git\ngit clone https://github.com/gicking/SPL_2.2.0_SDCC_patch.git\ncp ../STM8S_SPL_2.2.0/Libraries/STM8S_StdPeriph_Driver/inc/stm8s.h .\npatch -p1 < ../SPL_2.2.0_SDCC_patch/STM8_SPL_v2.2.0_SDCC.patch\ncp -av  ../STM8S_StdPeriph_Lib/Project/STM8S_StdPeriph_Template/stm8s_conf.h .\ncp -av  ../STM8S_StdPeriph_Lib/Project/STM8S_StdPeriph_Template/stm8s_it.h .\n\n\n\nSDCC uses .rel as the file extension for its object files.\n\n\nAdditional patch required for stm8s_itc.c:\n\n\n--- stm8s_itc.c~    2014-10-21 17:32:20.000000000 +0200\n+++ stm8s_itc.c 2016-12-11 21:56:41.786048494 +0100\n@@ -55,9 +55,12 @@\n   return; /* Ignore compiler warning, the returned value is in A register */\n #elif defined _RAISONANCE_ /* _RAISONANCE_ */\n   return _getCC_();\n-#else /* _IAR_ */\n+#elif defined _IAR_ /* _IAR_ */\n   asm(\"push cc\");\n   asm(\"pop a\"); /* Ignore compiler warning, the returned value is in A register */\n+#else /* _SDCC_ */\n+  __asm__(\"push cc\");\n+  __asm__(\"pop a\"); /* Ignore compiler warning, the returned value is in A register */\n #endif /* _COSMIC_*/\n }\n\n\n\n\nNow the library can be compiled for the STM8S103 using this Makefile:\n\n\nCC=sdcc\nAR=sdar\nCFLAGS=-c -mstm8 -DSTM8S103 -I ../inc --opt-code-size -I.\nLDFLAGS=-rc\nSOURCES= \\\n    stm8s_adc1.c    stm8s_awu.c stm8s_beep.c    stm8s_clk.c \\\n    stm8s_exti.c    stm8s_flash.c   stm8s_gpio.c    stm8s_i2c.c \\\n    stm8s_itc.c stm8s_iwdg.c    stm8s_rst.c stm8s_spi.c \\\n    stm8s_tim1.c    stm8s_tim2.c    stm8s_tim4.c    stm8s_uart1.c \\\n    stm8s_wwdg.c\n\nOBJECTS=$(SOURCES:.c=.o)\nOBJECTS_LINK=$(SOURCES:.c=.rel)\nEXECUTABLE=stm8s.lib\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n$(AR) $(LDFLAGS) $(EXECUTABLE) $(OBJECTS_LINK)\n\n.c.o:\n    $(CC) $(CFLAGS) $< -o $@\n\nclean:\n    rm -f *.lib *.rst *.rel *.lst *.ihx *.sym *.asm *.lk *.map\n    rm -f $(EXECUTABLE)\n\n\n\n\nThis library can now be used for linking with blink_spl or uart_spl. The\nfiles stm8s_conf.h and stm8s_it.h are still needed for compilation.\n\n\nThe linker does not remove individual unused functions from an object file,\nonly complete object files can be skipped.\n\n\n=> for building a library it is better to separate all functions into\nindividual source files \n\n\nThe SPL folder in this archive contains a script \ndoit\n to separate the\nfunctions before compilation.\nFIXME: description needed\n\n\nErkl\u00e4rung wie zumindest die Interrupt-Vektoren in die eigene Datei kommen\nk\u00f6nnen:\nhttp://richs-words.blogspot.de/2010/09/stm8s-interrupt-handling.html\n\n\nInterrupts\n\n\nNamen definiert in stm8s_itc.h\nInterrupt-Routine definieren:\n\n\n/* UART1 TX */\nvoid UART1_TX_IRQHandler(void) __interrupt(ITC_IRQ_UART1_TX)\n{\n}\n\n\n\n\nJetzt muss noch das passende IRQ-Enable-Flag gesetzt werden und Interrupt\ngenerell freigegeben werden, also hier:\n\n\nUART1_ITConfig(UART1_IT_TXE, ENABLE);\nenableInterrupts();\n\n\n\n\nUnklar ist, was die ITC-Priorit\u00e4ten bewirken. Es geht jedenfalls auch ohne:\n\n\nITC_DeInit();\nITC_SetSoftwarePriority(ITC_IRQ_UART1_TX, ITC_PRIORITYLEVEL_2);",
            "title": "Using the SPL with SDCC and sduino"
        },
        {
            "location": "/spl/#st-standard-library",
            "text": "Can be [downloaded from the ST website]\n(http://www.st.com/en/embedded-software/stsw-stm8069.html)\n(free registration required). Don't miss the Examples folder within the\ndownloaded zip file. This is the most useful reference on using this library\nand programming the STM8 in general.  For use with SDCC the library needs to be patched:  git clone https://github.com/g-gabber/STM8S_StdPeriph_Driver.git\ngit clone https://github.com/gicking/SPL_2.2.0_SDCC_patch.git\ncp ../STM8S_SPL_2.2.0/Libraries/STM8S_StdPeriph_Driver/inc/stm8s.h .\npatch -p1 < ../SPL_2.2.0_SDCC_patch/STM8_SPL_v2.2.0_SDCC.patch\ncp -av  ../STM8S_StdPeriph_Lib/Project/STM8S_StdPeriph_Template/stm8s_conf.h .\ncp -av  ../STM8S_StdPeriph_Lib/Project/STM8S_StdPeriph_Template/stm8s_it.h .  SDCC uses .rel as the file extension for its object files.  Additional patch required for stm8s_itc.c:  --- stm8s_itc.c~    2014-10-21 17:32:20.000000000 +0200\n+++ stm8s_itc.c 2016-12-11 21:56:41.786048494 +0100\n@@ -55,9 +55,12 @@\n   return; /* Ignore compiler warning, the returned value is in A register */\n #elif defined _RAISONANCE_ /* _RAISONANCE_ */\n   return _getCC_();\n-#else /* _IAR_ */\n+#elif defined _IAR_ /* _IAR_ */\n   asm(\"push cc\");\n   asm(\"pop a\"); /* Ignore compiler warning, the returned value is in A register */\n+#else /* _SDCC_ */\n+  __asm__(\"push cc\");\n+  __asm__(\"pop a\"); /* Ignore compiler warning, the returned value is in A register */\n #endif /* _COSMIC_*/\n }  Now the library can be compiled for the STM8S103 using this Makefile:  CC=sdcc\nAR=sdar\nCFLAGS=-c -mstm8 -DSTM8S103 -I ../inc --opt-code-size -I.\nLDFLAGS=-rc\nSOURCES= \\\n    stm8s_adc1.c    stm8s_awu.c stm8s_beep.c    stm8s_clk.c \\\n    stm8s_exti.c    stm8s_flash.c   stm8s_gpio.c    stm8s_i2c.c \\\n    stm8s_itc.c stm8s_iwdg.c    stm8s_rst.c stm8s_spi.c \\\n    stm8s_tim1.c    stm8s_tim2.c    stm8s_tim4.c    stm8s_uart1.c \\\n    stm8s_wwdg.c\n\nOBJECTS=$(SOURCES:.c=.o)\nOBJECTS_LINK=$(SOURCES:.c=.rel)\nEXECUTABLE=stm8s.lib\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n$(AR) $(LDFLAGS) $(EXECUTABLE) $(OBJECTS_LINK)\n\n.c.o:\n    $(CC) $(CFLAGS) $< -o $@\n\nclean:\n    rm -f *.lib *.rst *.rel *.lst *.ihx *.sym *.asm *.lk *.map\n    rm -f $(EXECUTABLE)  This library can now be used for linking with blink_spl or uart_spl. The\nfiles stm8s_conf.h and stm8s_it.h are still needed for compilation.  The linker does not remove individual unused functions from an object file,\nonly complete object files can be skipped.  => for building a library it is better to separate all functions into\nindividual source files   The SPL folder in this archive contains a script  doit  to separate the\nfunctions before compilation.\nFIXME: description needed  Erkl\u00e4rung wie zumindest die Interrupt-Vektoren in die eigene Datei kommen\nk\u00f6nnen:\nhttp://richs-words.blogspot.de/2010/09/stm8s-interrupt-handling.html  Interrupts  Namen definiert in stm8s_itc.h\nInterrupt-Routine definieren:  /* UART1 TX */\nvoid UART1_TX_IRQHandler(void) __interrupt(ITC_IRQ_UART1_TX)\n{\n}  Jetzt muss noch das passende IRQ-Enable-Flag gesetzt werden und Interrupt\ngenerell freigegeben werden, also hier:  UART1_ITConfig(UART1_IT_TXE, ENABLE);\nenableInterrupts();  Unklar ist, was die ITC-Priorit\u00e4ten bewirken. Es geht jedenfalls auch ohne:  ITC_DeInit();\nITC_SetSoftwarePriority(ITC_IRQ_UART1_TX, ITC_PRIORITYLEVEL_2);",
            "title": "ST Standard Library"
        },
        {
            "location": "/macro/",
            "text": "Preprocessor macros to disguise plain C as C++\n\n\nPorting some Arduino-like functions to C is not too difficult. The challenge\nis to keep the syntax differences to the real C++-based Arduino system as\nsmall a possible while still using plain C.\n\n\nThere are subtle differences in the API concepts of the Arduino libraries.\nUnfortunatly, they all require different strategies to mimic a C++ user API.\nThe basic criteria are:\n\n\n\n\n\n\nmulti-instance or single-instance\n\n\n\n\n\n\nis a constructor call mandatory or not (typically the \nbegin()\n-method)\n\n\n\n\n\n\nAdditionally, there are some more detailed destinctions:\n\n\n\n\n\n\npolymorph instantiation declaration or simple declaration\n\n\n\n\n\n\ngeneral single instance library or pre-instantiated single instance\n  library\n\n\n\n\n\n\ninheritance via virtual methods (most output-type libraries inherit from\n  the Print class)\n\n\n\n\n\n\nAs a result, there are several different cases to consider:\n\n\nSingle-instance, pre-instantiated, with constructor\n\n\nThe data is kept locally within the class module. There is no\n  instantiation declaration. No instance references need to be passed to any\n  any function calls. All initialization is done by the constructor\n  function.\n\n\nThis is the easiest and most straight-forward case. No help from the\n  preprocessor is required. It is sufficient to choose the function names to\n  match the original class::method names. Polymorph methods are represented\n  by a set of name-mangled functions.\n\n\nThe behaviour of this construction is very similar to a real C++ class.\n\n\nExamples:\n\n\nSPI\n, \nI2C\n,\n\nHardwareSerial\n \n\n\n#include <I2C.h>\n\nsetup() {\n    I2c_begin();\n    I2c_write(0x1e, 0x02,0x00);\n}\n\n\n\n\n\nRequired preprocessor help\n\n\n\n\nnone\n\n\n\n\nSingle-instance, with constructor\n\n\nThe data is kept locally within the class module. The instantiation\n  declaration defines the one instance name to be used. It might pass some\n  configuration data which is remembered for later use. As there is always\n  exactly one instance, no instance references need to be remembered and\n  passed to any function calls. The instance name is more a cosmetic issue.\n\n\nThe constructor does the actual configuration and initialization. It might\n  use the configuration data given earlier with the instantiation\n  declaration.\n\n\nThe behaviour of this construction is very similar to a real C++ class.\n\n\nPolymorph instantiation declarations are possible.\n  Non-constant values for the initialization are supported.\n\n\nExamples:\n \nLiquidCrystal\n\n\nint rs_pin = 2;\n\nLiquidCrystal (lcd, rs_pin,3,4, 5,6,7,8);\n\nsetup() {\n    lcd_begin(16,2);\n    lcd_setCursor(0,1);\n    lcd_print_s(\"Hello, world!\");\n}\n\n\n\n\nRequired preprocessor help\n\n\n\n\npolymorph instantiation\n\n\nremember configuration data for later use with the constructor\n\n\nsetting up alias definitions to include the instance name in the function\n  names.\n\n\n\n\nMulti-instance class, with constructor\n\n\nThe data can be kept locally within the class module. The constructor\n  allocates and initializes the required data structure and does required\n  I/O-initializations. It returns a reference item to identify the instance.\n  This reference item is typically a pointer to the instance structure or\n  and index number to an internal table. It is passed to any following\n  method call.\n\n\nThe behaviour of this construction is very similar to a real C++ class.\n  The main pitfall is the missing automatic destructor call. Luckily, this\n  C++ feature is rarely used, anyway.\n\n\nPolymorph instantiation declarations are possible.\n\n\nExamples: \nServo\n\n\n#include <Servo.h>\n\nServo(servo1);\nServo(servo2);\n\nsetup() {\n    servo1_attach(5);\n    servo2_attach(6);\n}\n\nloop() {\n    servo1_write(90);\n    servo2_write(150);\n}\n\n\n\n\nRequired preprocessor help\n\n\n\n\npolymorph instantiation\n\n\nremember configuration data for later use with the constructor\n\n\nsave the instance reference item on initialization\n\n\nsetting up alias definitions to \n\n\ninclude the instance name in the function names and\n\n\ninclude the instance reference item with the parameter list of every function call.\n\n\n\n\nMulti-instance class, no constructor\n\n\nAs there is no strictly defined first function call which could allocate\n  and initialize internal data structures, the data has to be kept in a data\n  structure in the user area. A pointer to this data structure is passed to\n  any following method call.\n\n\nThis case can be difficult. As there is no dedicated constructor call, the\n  library has to keep track if the current instance has been initialized\n  already and has to do so if not. That means, that the needed I/O resources\n  can't be initialized before the first function call. That might be a\n  problem for some applications as I/O pins might stay in a floating input\n  state for quite some time.\n\n\nSecond drawback of this concept is the fact, that the instance data\n  initialization values have to be known at compile time and can't be\n  variables or the result of function calls at run time, e.g. from a\n  configuration space in EEPROM.\n\n\nTo solve these two problems it might be necessary to introduce an\n  additional constructor-type function, that can be called from the setup()\n  function or for any needed reconfiguration. Since the instance data is in\n  the user space anyway, it could be modified there directly. But this would\n  be an even worse violation of all modularization concepts and should be\n  avoided.\n\n\nPolymorph instantiation declarations are possible.\n\n\nExamples: \nStepper\n\n\nBy requiring the user to add a call to the added constructor as the\n  mandatory first call to the instance it could be treated as any other\n  multi-instance class with constructor, see above. The resulting API is not\n  identical to Arduino anymore, but still very similar.\n\n\n#include <Stepper.h>\n\nStepper (StepperA, 100, 6, 7);\nStepper (StepperB, 200, 8, 9, 10, 11);\n\nvoid setup() {\n  StepperA_setSpeed(60);\n  StepperB_setSpeed(60);\n}\n\nvoid loop() {\n  StepperA_step(20);\n  StepperB_step(40);\n}\n\n\n\n\nRequired preprocessor help\n\n\n\n\npolymorph instantiation.\n\n\nconvert the instantiation declaration into an instance data item declaration\n  and initialization.\n\n\nsetting up alias definitions to \n\n\ninclude the instance name in the function names and\n\n\ninclude a pointer to the instance data item with the parameter list of\n    every function call.\n\n\n\n\nInheritance\n\n\nMost output-type libraries inherit the methods from class Print by providing\na matching write() method. This works by providing all print functions a\nfunction pointer to the write function, that should be used.\n\n\nRequired preprocessor help\n\n\n\n\nsetting up alias definitions to \n\n\ninclude the instance name of the output module in the function names of\n    the print functions and\n\n\ninclude a pointer to the output write function with the parameter list of\n    every (aliased) print function call.",
            "title": "C preprocessor macro magic"
        },
        {
            "location": "/macro/#preprocessor-macros-to-disguise-plain-c-as-c",
            "text": "Porting some Arduino-like functions to C is not too difficult. The challenge\nis to keep the syntax differences to the real C++-based Arduino system as\nsmall a possible while still using plain C.  There are subtle differences in the API concepts of the Arduino libraries.\nUnfortunatly, they all require different strategies to mimic a C++ user API.\nThe basic criteria are:    multi-instance or single-instance    is a constructor call mandatory or not (typically the  begin() -method)    Additionally, there are some more detailed destinctions:    polymorph instantiation declaration or simple declaration    general single instance library or pre-instantiated single instance\n  library    inheritance via virtual methods (most output-type libraries inherit from\n  the Print class)    As a result, there are several different cases to consider:",
            "title": "Preprocessor macros to disguise plain C as C++"
        },
        {
            "location": "/macro/#single-instance-pre-instantiated-with-constructor",
            "text": "The data is kept locally within the class module. There is no\n  instantiation declaration. No instance references need to be passed to any\n  any function calls. All initialization is done by the constructor\n  function.  This is the easiest and most straight-forward case. No help from the\n  preprocessor is required. It is sufficient to choose the function names to\n  match the original class::method names. Polymorph methods are represented\n  by a set of name-mangled functions.  The behaviour of this construction is very similar to a real C++ class.  Examples:  SPI ,  I2C , HardwareSerial    #include <I2C.h>\n\nsetup() {\n    I2c_begin();\n    I2c_write(0x1e, 0x02,0x00);\n}  Required preprocessor help   none",
            "title": "Single-instance, pre-instantiated, with constructor"
        },
        {
            "location": "/macro/#single-instance-with-constructor",
            "text": "The data is kept locally within the class module. The instantiation\n  declaration defines the one instance name to be used. It might pass some\n  configuration data which is remembered for later use. As there is always\n  exactly one instance, no instance references need to be remembered and\n  passed to any function calls. The instance name is more a cosmetic issue.  The constructor does the actual configuration and initialization. It might\n  use the configuration data given earlier with the instantiation\n  declaration.  The behaviour of this construction is very similar to a real C++ class.  Polymorph instantiation declarations are possible.\n  Non-constant values for the initialization are supported.  Examples:   LiquidCrystal  int rs_pin = 2;\n\nLiquidCrystal (lcd, rs_pin,3,4, 5,6,7,8);\n\nsetup() {\n    lcd_begin(16,2);\n    lcd_setCursor(0,1);\n    lcd_print_s(\"Hello, world!\");\n}  Required preprocessor help   polymorph instantiation  remember configuration data for later use with the constructor  setting up alias definitions to include the instance name in the function\n  names.",
            "title": "Single-instance, with constructor"
        },
        {
            "location": "/macro/#multi-instance-class-with-constructor",
            "text": "The data can be kept locally within the class module. The constructor\n  allocates and initializes the required data structure and does required\n  I/O-initializations. It returns a reference item to identify the instance.\n  This reference item is typically a pointer to the instance structure or\n  and index number to an internal table. It is passed to any following\n  method call.  The behaviour of this construction is very similar to a real C++ class.\n  The main pitfall is the missing automatic destructor call. Luckily, this\n  C++ feature is rarely used, anyway.  Polymorph instantiation declarations are possible.  Examples:  Servo  #include <Servo.h>\n\nServo(servo1);\nServo(servo2);\n\nsetup() {\n    servo1_attach(5);\n    servo2_attach(6);\n}\n\nloop() {\n    servo1_write(90);\n    servo2_write(150);\n}  Required preprocessor help   polymorph instantiation  remember configuration data for later use with the constructor  save the instance reference item on initialization  setting up alias definitions to   include the instance name in the function names and  include the instance reference item with the parameter list of every function call.",
            "title": "Multi-instance class, with constructor"
        },
        {
            "location": "/macro/#multi-instance-class-no-constructor",
            "text": "As there is no strictly defined first function call which could allocate\n  and initialize internal data structures, the data has to be kept in a data\n  structure in the user area. A pointer to this data structure is passed to\n  any following method call.  This case can be difficult. As there is no dedicated constructor call, the\n  library has to keep track if the current instance has been initialized\n  already and has to do so if not. That means, that the needed I/O resources\n  can't be initialized before the first function call. That might be a\n  problem for some applications as I/O pins might stay in a floating input\n  state for quite some time.  Second drawback of this concept is the fact, that the instance data\n  initialization values have to be known at compile time and can't be\n  variables or the result of function calls at run time, e.g. from a\n  configuration space in EEPROM.  To solve these two problems it might be necessary to introduce an\n  additional constructor-type function, that can be called from the setup()\n  function or for any needed reconfiguration. Since the instance data is in\n  the user space anyway, it could be modified there directly. But this would\n  be an even worse violation of all modularization concepts and should be\n  avoided.  Polymorph instantiation declarations are possible.  Examples:  Stepper  By requiring the user to add a call to the added constructor as the\n  mandatory first call to the instance it could be treated as any other\n  multi-instance class with constructor, see above. The resulting API is not\n  identical to Arduino anymore, but still very similar.  #include <Stepper.h>\n\nStepper (StepperA, 100, 6, 7);\nStepper (StepperB, 200, 8, 9, 10, 11);\n\nvoid setup() {\n  StepperA_setSpeed(60);\n  StepperB_setSpeed(60);\n}\n\nvoid loop() {\n  StepperA_step(20);\n  StepperB_step(40);\n}  Required preprocessor help   polymorph instantiation.  convert the instantiation declaration into an instance data item declaration\n  and initialization.  setting up alias definitions to   include the instance name in the function names and  include a pointer to the instance data item with the parameter list of\n    every function call.",
            "title": "Multi-instance class, no constructor"
        },
        {
            "location": "/macro/#inheritance",
            "text": "Most output-type libraries inherit the methods from class Print by providing\na matching write() method. This works by providing all print functions a\nfunction pointer to the write function, that should be used.  Required preprocessor help   setting up alias definitions to   include the instance name of the output module in the function names of\n    the print functions and  include a pointer to the output write function with the parameter list of\n    every (aliased) print function call.",
            "title": "Inheritance"
        },
        {
            "location": "/api/",
            "text": "Migrating existing code from C++ to C syntax\n\n\nThe original Arduino environment uses C++ syntax while sduino can only use\nplain C syntax. Luckily, not many C++ features are used and in most cases a\nconversion is not very hard. In most cases a conversion from C++ to C it is\njust a matter of exchanging a dot for an underscore:\n\n\nA C++ method name \nclass.method()\n becomes a C function name \nclass_method()\n.\n\n\nThis is possible since most libraries are written to be used as a singleton\nanyway, so the fixed name prefix is not a problem. Only very few libraries\nneed a slightly more complex approach to be able to deal with multiple\ninstances.\n\n\nThere are two bigger problems left:\n\n\nPolymorph functions\n\n\nThe concept of polymorphism does not exist for plain C. As a workaround\n'mangled' function names are used for the different parameter type\ncombinations supported by the original polymorph methods.\n\n\nTypical name extensions are: \n_u\n for unsigned values, \n_i\n for signed\ninteger values, \n_c\nfor characters, \n_s\n for strings, \n_n\n for data\nbuffer/length combinations.\n\n\nFor more non-regular polymorphism the name extension is often related to the\ndifferent use cases or to the names of the given parameters. Refer to the\nrespective library header file for details.\n\n\nSome examples of typical name changes:\n\n\n\n\n\n\n\n\nC++ name\n\n\nC name\n\n\n\n\n\n\n\n\n\n\nSerial.print(int)\n\n\nSerial_print_i\n\n\n\n\n\n\nSerial.print(unsigned)\n\n\nSerial_print_u\n\n\n\n\n\n\nSerial.print(char)\n\n\nSerial_print_c\n\n\n\n\n\n\nSerial.print(char *)\n\n\nSerial_print_s\n\n\n\n\n\n\nSerial.print(char *buf, int len)\n\n\nSerial_print_n\n\n\n\n\n\n\nSerial.print(unsigned n, int base)\n\n\nSerial_print_ub\n\n\n\n\n\n\nrandom(long)\n\n\nrandom\n\n\n\n\n\n\nrandom(long howsmall, long howbig)\n\n\nrandom_minmax\n\n\n\n\n\n\n\n\nThe _Generic selection\n\n\nThe C11 standard introduced the\n\n_Generic\n\nselection function. This function allows for automatic selection of\ndifferent function variants at compile time depending on the type of the\nfunction arguments mimicing polymorph C++ functions.\n\n\nRecent versions of SDCC already support this function (command line argument\n\n--std-sdcc99\n), but it's usefulness is still limited to some special cases.\n\n\n#define Serial_print(X) _Generic((X), \\\n    char*: Serial_print_s, \\\n    signed long: Serial_print_i, \\\n    signed int: Serial_print_i, \\\n    signed char: Serial_print_c, \\\n    unsigned long: Serial_print_u, \\\n    unsigned int: Serial_print_u, \\\n    unsigned char: Serial_print_u \\\n    )(X)\n\n\n\n\nThis would unify some, but not all print function variants:\n\n\n\n\n\n\n\n\nC++ name\n\n\nC name using _Generic\n\n\n\n\n\n\n\n\n\n\nSerial.print(int)\n\n\nSerial_print\n\n\n\n\n\n\nSerial.print(unsigned)\n\n\nSerial_print\n\n\n\n\n\n\nSerial.print(char)\n\n\nSerial_print\n\n\n\n\n\n\nSerial.print(char *)\n\n\nSerial_print_s\n\n\n\n\n\n\nSerial.print(char *buf, int len)\n\n\nSerial_print_n\n\n\n\n\n\n\nSerial.print(unsigned n, int base)\n\n\nSerial_print_ub\n\n\n\n\n\n\n\n\nUnfortunately cpp does not match string constants and \nchar*\n resulting in a\nvery non-regular usage pattern:\n\n\nchar *string=\"Hello\";\n\nSerial_print(string);   // works\nSerial_print(\"Hello\");  // doesn't work\nSerial_print_s(\"Hello\");// works\n\n\n\nTo avoid too much confusion it might be better to not use \n_Generic\n at all.\n\n\nAnother problem using the \n_Generic\n selector is configurable instance\nnames. The preprocessor does not allow for variable macro names. That means\n\n_Generic\n would work with fixed name like \nSerial\n, but it wouldn't work\nfor \nSoftwareSerial\n with no standard instance name.\n\n\nInheritance from Print class\n\n\nMost character output modules inherit methods from the Print class by\nproviding a virtual write method. A similar result can be achived by\nproviding a function pointer to the write function to be used to the print\nfunctions.\n\n\nThis additional parameter is hidden from the user by providing more\nconvinient defines in every library that need to 'inherit' functions from\nPrint. This way \nlcd.print(\"Hello World!\")\n becomes \nlcd_print_s(\"Hello\nWorld!\")\n and \nSerial.print(\"Hello World!\")\n becomes \nSerial_print_s(\"Hello\nWorld!\")\n. Both call the same code from Print, but with different function\npointers to their own putchar/write function.\n\n\nLibraries with multiple instances\n\n\nIf multiple instances need to be supported, an approach similar to a C file\ndescriptor is used. The \"constructor\" function allocates and initializes a\ndata structure for one particular instance and return a pointer to this\nstructure. Typically, this is done in the \nsetup()\n-function and this pointer \nis stored in a global variable to be used as a device descriptor.\n\n\nSo far the \nStepper library\n is the only example:\n\n\n#include <Stepper.h>\nStepper myStepper;      // variable to store the \"device descriptor\"\nvoid setup(void) {\n    myStepper = Stepper_2phase(100,11,12);  // init a 2 phase stepper\n}\nvoid loop() {\n    Stepper_step(myStepper, 20);        // do 20 steps forward\n}\n\n\n\n\nDifferences from the original Arduino environment\n\n\nAdditional output pin modes\n\n\n\n\n\n\n\n\nPin mode\n\n\nPin properties\n\n\n\n\n\n\n\n\n\n\nOUTPUT\n\n\noutput, push-pull, slow mode (default)\n\n\n\n\n\n\nOUTPUT_OD\n\n\noutput, open drain, fast mode\n\n\n\n\n\n\nOUTPUT_FAST\n\n\noutput, push-pull, fast mode\n\n\n\n\n\n\nOUTPUT_OD_FAST\n\n\noutput, open drain, fast mode\n\n\n\n\n\n\n\n\nTimer\n\n\nmillis()\n uses timer4. The prescaler and end value is calculated at compile\ntime for a cycle time as close to 1ms as possible. Default values @16Mhz:\nprescaler=64, counter cycle=250 (end value=249), resulting in exactly 1ms\nintervals.\n\n\ntimer1: PWM for PC3, PC4, on alternate mapping PC6, PC7, could be used for ADC\n\ntimer2: PWM for PA3, PD3, PD4 or PC5 (mutual exclusive)\n\ntimer4: millis()  \n\n\nLeaving out unused parts\n\n\nSome functions of the core Arduino system can be left out on compilation to\nsave code space. This is done by compiler flags that can be defined in the\nMakefile:\n\n\nBOARD_TAG = stm8sblue\nCFLAGS = -DNO_SERIAL -DNO_ANALOG_IN -DNO_ANALOG_OUT\n\ninclude ../../../sduino.mk\n\n\n\n\nThese flags are supported:\n\n\n\n\n\n\n\n\nFlag\n\n\nBytes saved\n\n\nFunctions lost\n\n\n\n\n\n\n\n\n\n\nNO_SERIAL\n\n\n765\n\n\nall serial communication\n\n\n\n\n\n\nNO_ANALOG_OUT\n\n\n406\n\n\nanalogWrite()\n\n\n\n\n\n\nNO_ANALOG_IN\n\n\n56\n\n\nanalogRead()\n\n\n\n\n\n\n\n\nOther modifications\n\n\nmakeWord(unsigned char, unsigned char)\n is an inline function now.\n\n\nAdditional compile-time flags\n\n\nSome internal details can be influenced by setting compile-time defines\nusing the \nCFLAGS=-Dflagname\n line in the Makefile.\n\n\nSUPPORT_ALTERNATE_MAPPINGS\n:\nAllow the use of \nalternateFunctions()\n\n\nENABLE_SWIM\n:\nDo not disable the remote debugging function on the SWIM pin. This means\nthat this pin can not be used for normal I/O functions.\n\n\nUSE_SPL\n:\nUse SPL functions for I/O access instead of direct register accesses. Useful\nonly for debugging and porting to other CPU variants. Do not use for regular\ndevelopment.\n\n\nGeneral notes on the Arduino port\n\n\nADC\n\n\nthe prescaler is initialised for an ADC clock in the range of 1..2 MHz. The\nminimum prescaler value is 2, so for a clock speed of less than 2 MHz the\nrequired minimum ADC clock frequency can not be reached anymore.\n\n\nMapping of logical pin numbers to register addresses\n\n\nThe lookup-table approach for assigning port and bit adresses to the logical\npin numbers is not effient on the STM8. The hole system could be changed to\na more regular scheme and replace the tables by hardcoded adress\ncalculations.\n\n\nInefficient compilation\n\n\ndigitalWrite\n compiles very ineffiently. It might be worth some hand\noptimization.\n\n\nAccessing the alternate pin functions\n\n\nAdded \nalternateFunction()\n to allow switching of some pins to their alternate\nfunctions. This allows for three more PWM pins, but maybe it adds to much\ncomplexity for the Arduino API. Not sure if it should stay. Has to be\nenabled by defining \nSUPPORT_ALTERNATE_MAPPINGS\n.\n\n\nUseful CPU features that are not supported by the Arduino API\n\n\nInput-Capture-Mode:\n Available for all four channels, at least for timer1. Would be great for precise time measurements. Maybe build a library?\n\n\nEncoder interface mode:\n Kann von Haus aus mit Quadratur-Encodern umgehen\nund in Hardware z\u00e4hlen -> perfekt f\u00fcr die Druckerschlitten-Motorsteuerung.",
            "title": "API description and migration guidelines"
        },
        {
            "location": "/api/#migrating-existing-code-from-c-to-c-syntax",
            "text": "The original Arduino environment uses C++ syntax while sduino can only use\nplain C syntax. Luckily, not many C++ features are used and in most cases a\nconversion is not very hard. In most cases a conversion from C++ to C it is\njust a matter of exchanging a dot for an underscore:  A C++ method name  class.method()  becomes a C function name  class_method() .  This is possible since most libraries are written to be used as a singleton\nanyway, so the fixed name prefix is not a problem. Only very few libraries\nneed a slightly more complex approach to be able to deal with multiple\ninstances.  There are two bigger problems left:",
            "title": "Migrating existing code from C++ to C syntax"
        },
        {
            "location": "/api/#polymorph-functions",
            "text": "The concept of polymorphism does not exist for plain C. As a workaround\n'mangled' function names are used for the different parameter type\ncombinations supported by the original polymorph methods.  Typical name extensions are:  _u  for unsigned values,  _i  for signed\ninteger values,  _c for characters,  _s  for strings,  _n  for data\nbuffer/length combinations.  For more non-regular polymorphism the name extension is often related to the\ndifferent use cases or to the names of the given parameters. Refer to the\nrespective library header file for details.  Some examples of typical name changes:     C++ name  C name      Serial.print(int)  Serial_print_i    Serial.print(unsigned)  Serial_print_u    Serial.print(char)  Serial_print_c    Serial.print(char *)  Serial_print_s    Serial.print(char *buf, int len)  Serial_print_n    Serial.print(unsigned n, int base)  Serial_print_ub    random(long)  random    random(long howsmall, long howbig)  random_minmax     The _Generic selection  The C11 standard introduced the _Generic \nselection function. This function allows for automatic selection of\ndifferent function variants at compile time depending on the type of the\nfunction arguments mimicing polymorph C++ functions.  Recent versions of SDCC already support this function (command line argument --std-sdcc99 ), but it's usefulness is still limited to some special cases.  #define Serial_print(X) _Generic((X), \\\n    char*: Serial_print_s, \\\n    signed long: Serial_print_i, \\\n    signed int: Serial_print_i, \\\n    signed char: Serial_print_c, \\\n    unsigned long: Serial_print_u, \\\n    unsigned int: Serial_print_u, \\\n    unsigned char: Serial_print_u \\\n    )(X)  This would unify some, but not all print function variants:     C++ name  C name using _Generic      Serial.print(int)  Serial_print    Serial.print(unsigned)  Serial_print    Serial.print(char)  Serial_print    Serial.print(char *)  Serial_print_s    Serial.print(char *buf, int len)  Serial_print_n    Serial.print(unsigned n, int base)  Serial_print_ub     Unfortunately cpp does not match string constants and  char*  resulting in a\nvery non-regular usage pattern:  char *string=\"Hello\";\n\nSerial_print(string);   // works\nSerial_print(\"Hello\");  // doesn't work\nSerial_print_s(\"Hello\");// works  To avoid too much confusion it might be better to not use  _Generic  at all.  Another problem using the  _Generic  selector is configurable instance\nnames. The preprocessor does not allow for variable macro names. That means _Generic  would work with fixed name like  Serial , but it wouldn't work\nfor  SoftwareSerial  with no standard instance name.",
            "title": "Polymorph functions"
        },
        {
            "location": "/api/#inheritance-from-print-class",
            "text": "Most character output modules inherit methods from the Print class by\nproviding a virtual write method. A similar result can be achived by\nproviding a function pointer to the write function to be used to the print\nfunctions.  This additional parameter is hidden from the user by providing more\nconvinient defines in every library that need to 'inherit' functions from\nPrint. This way  lcd.print(\"Hello World!\")  becomes  lcd_print_s(\"Hello\nWorld!\")  and  Serial.print(\"Hello World!\")  becomes  Serial_print_s(\"Hello\nWorld!\") . Both call the same code from Print, but with different function\npointers to their own putchar/write function.",
            "title": "Inheritance from Print class"
        },
        {
            "location": "/api/#libraries-with-multiple-instances",
            "text": "If multiple instances need to be supported, an approach similar to a C file\ndescriptor is used. The \"constructor\" function allocates and initializes a\ndata structure for one particular instance and return a pointer to this\nstructure. Typically, this is done in the  setup() -function and this pointer \nis stored in a global variable to be used as a device descriptor.  So far the  Stepper library  is the only example:  #include <Stepper.h>\nStepper myStepper;      // variable to store the \"device descriptor\"\nvoid setup(void) {\n    myStepper = Stepper_2phase(100,11,12);  // init a 2 phase stepper\n}\nvoid loop() {\n    Stepper_step(myStepper, 20);        // do 20 steps forward\n}",
            "title": "Libraries with multiple instances"
        },
        {
            "location": "/api/#differences-from-the-original-arduino-environment",
            "text": "Additional output pin modes     Pin mode  Pin properties      OUTPUT  output, push-pull, slow mode (default)    OUTPUT_OD  output, open drain, fast mode    OUTPUT_FAST  output, push-pull, fast mode    OUTPUT_OD_FAST  output, open drain, fast mode     Timer  millis()  uses timer4. The prescaler and end value is calculated at compile\ntime for a cycle time as close to 1ms as possible. Default values @16Mhz:\nprescaler=64, counter cycle=250 (end value=249), resulting in exactly 1ms\nintervals.  timer1: PWM for PC3, PC4, on alternate mapping PC6, PC7, could be used for ADC \ntimer2: PWM for PA3, PD3, PD4 or PC5 (mutual exclusive) \ntimer4: millis()    Leaving out unused parts  Some functions of the core Arduino system can be left out on compilation to\nsave code space. This is done by compiler flags that can be defined in the\nMakefile:  BOARD_TAG = stm8sblue\nCFLAGS = -DNO_SERIAL -DNO_ANALOG_IN -DNO_ANALOG_OUT\n\ninclude ../../../sduino.mk  These flags are supported:     Flag  Bytes saved  Functions lost      NO_SERIAL  765  all serial communication    NO_ANALOG_OUT  406  analogWrite()    NO_ANALOG_IN  56  analogRead()     Other modifications  makeWord(unsigned char, unsigned char)  is an inline function now.  Additional compile-time flags  Some internal details can be influenced by setting compile-time defines\nusing the  CFLAGS=-Dflagname  line in the Makefile.  SUPPORT_ALTERNATE_MAPPINGS :\nAllow the use of  alternateFunctions()  ENABLE_SWIM :\nDo not disable the remote debugging function on the SWIM pin. This means\nthat this pin can not be used for normal I/O functions.  USE_SPL :\nUse SPL functions for I/O access instead of direct register accesses. Useful\nonly for debugging and porting to other CPU variants. Do not use for regular\ndevelopment.",
            "title": "Differences from the original Arduino environment"
        },
        {
            "location": "/api/#general-notes-on-the-arduino-port",
            "text": "ADC  the prescaler is initialised for an ADC clock in the range of 1..2 MHz. The\nminimum prescaler value is 2, so for a clock speed of less than 2 MHz the\nrequired minimum ADC clock frequency can not be reached anymore.  Mapping of logical pin numbers to register addresses  The lookup-table approach for assigning port and bit adresses to the logical\npin numbers is not effient on the STM8. The hole system could be changed to\na more regular scheme and replace the tables by hardcoded adress\ncalculations.  Inefficient compilation  digitalWrite  compiles very ineffiently. It might be worth some hand\noptimization.  Accessing the alternate pin functions  Added  alternateFunction()  to allow switching of some pins to their alternate\nfunctions. This allows for three more PWM pins, but maybe it adds to much\ncomplexity for the Arduino API. Not sure if it should stay. Has to be\nenabled by defining  SUPPORT_ALTERNATE_MAPPINGS .  Useful CPU features that are not supported by the Arduino API  Input-Capture-Mode:  Available for all four channels, at least for timer1. Would be great for precise time measurements. Maybe build a library?  Encoder interface mode:  Kann von Haus aus mit Quadratur-Encodern umgehen\nund in Hardware z\u00e4hlen -> perfekt f\u00fcr die Druckerschlitten-Motorsteuerung.",
            "title": "General notes on the Arduino port"
        },
        {
            "location": "/api/HardwareSerial/",
            "text": "HardwareSerial\n\n\nUses the UART. API similar to Arduino. Single instance only.\nPre-instanciated.\n\n\nThis page is only a stub.\n\n\nAPI\n\n\nExample\n\n\nImplementation details\n\n\nPossible impovements",
            "title": "HardwareSerial"
        },
        {
            "location": "/api/HardwareSerial/#hardwareserial",
            "text": "Uses the UART. API similar to Arduino. Single instance only.\nPre-instanciated.  This page is only a stub.",
            "title": "HardwareSerial"
        },
        {
            "location": "/api/HardwareSerial/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/api/HardwareSerial/#example",
            "text": "",
            "title": "Example"
        },
        {
            "location": "/api/HardwareSerial/#implementation-details",
            "text": "",
            "title": "Implementation details"
        },
        {
            "location": "/api/HardwareSerial/#possible-impovements",
            "text": "",
            "title": "Possible impovements"
        },
        {
            "location": "/api/SPI/",
            "text": "SPI\n\n\nReal hardware-SPI up to 10MHz. No interrupt support yet.\n\n\nThis page is only a stub.\n\n\nAPI\n\n\nExample\n\n\nImplementation details\n\n\nPossible impovements",
            "title": "SPI"
        },
        {
            "location": "/api/SPI/#spi",
            "text": "Real hardware-SPI up to 10MHz. No interrupt support yet.  This page is only a stub.",
            "title": "SPI"
        },
        {
            "location": "/api/SPI/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/api/SPI/#example",
            "text": "",
            "title": "Example"
        },
        {
            "location": "/api/SPI/#implementation-details",
            "text": "",
            "title": "Implementation details"
        },
        {
            "location": "/api/SPI/#possible-impovements",
            "text": "",
            "title": "Possible impovements"
        },
        {
            "location": "/api/I2C/",
            "text": "I2C\n\n\nThe\n\nI2C master library\n\nby Wayne Truchsess offers some significant advantages over the Wire/TWI\nlibrary included in the standard arduino environment: It fixes some possible\ndeadlock situations, it allows for communication using a repeated start\ncondition as required by some devices, the code is much more compact and the\nstructure is easier to understand.\n\n\nThe current state of the port does not include the deadlock protection,\nthough.",
            "title": "I2C"
        },
        {
            "location": "/api/I2C/#i2c",
            "text": "The I2C master library \nby Wayne Truchsess offers some significant advantages over the Wire/TWI\nlibrary included in the standard arduino environment: It fixes some possible\ndeadlock situations, it allows for communication using a repeated start\ncondition as required by some devices, the code is much more compact and the\nstructure is easier to understand.  The current state of the port does not include the deadlock protection,\nthough.",
            "title": "I2C"
        },
        {
            "location": "/api/LiquidCrystal/",
            "text": "LiquidCrystal Library\n\n\nThis library is for character LCDs based on the HD44780 controller.\nDerived from the Arduino LiquidCrystal library v1.8.0.\n\n\nAPI\n\n\nThis library is a singleton library, it is not possible to use more than one\ninstance per sketch.\n\n\nThe API syntax is very similar to the original C++ syntax, thanks to some\n\nc preprocessor macro magic\n.\n\n\nApart from the usual name mangeling for polymorph functions (mostly the\ndifferent variants of the Print::print method) moving the opening bracket at\nthe class declarator line and replacing the dots in the method names for\nunderscores is all it needs.\n\n\n\n\n\n\n\n\nArduino syntax\n\n\nsduino syntax\n\n\n\n\n\n\n\n\n\n\nLiquidCrystal lcd(rs,en,d0,d1,d2,d3)\n\n\nLiquidCrystal (lcd,rs,en,d0,d1,d2,d3)\n\n\n\n\n\n\nLiquidCrystal lcd(rs,rw,en,d0,d1,d2,d3)\n\n\nLiquidCrystal (lcd,rs,rw,en,d0,d1,d2,d3)\n\n\n\n\n\n\nLiquidCrystal lcd(rs,en,d0,d1,d2,d3,d4,d5,d6,d7)\n\n\nLiquidCrystal (lcd,rs,en,d0,d1,d2,d3,d4,d5,d6,d7)\n\n\n\n\n\n\nLiquidCrystal lcd(rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7)\n\n\nLiquidCrystal (lcd,rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7)\n\n\n\n\n\n\nlcd.init(rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7)\n\n\nlcd_init(mode,rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7)\n\n\n\n\n\n\nlcd.begin(cols,lines)\n\n\nlcd_begin(cols,lines)\n\n\n\n\n\n\nlcd.begin(cols,lines,charsize)\n\n\nlcd_begin_charsize(cols,lines,charsize)\n\n\n\n\n\n\nlcd.clear()\n\n\nlcd_clear()\n\n\n\n\n\n\nlcd.home()\n\n\nlcd_home()\n\n\n\n\n\n\nlcd.noDisplay()\n\n\nlcd_noDisplay()\n\n\n\n\n\n\nlcd.display()\n\n\nlcd_display()\n\n\n\n\n\n\nlcd.noBlink()\n\n\nlcd_noBlink()\n\n\n\n\n\n\nlcd.blink()\n\n\nlcd_blink()\n\n\n\n\n\n\nlcd.noCursor()\n\n\nlcd_noCursor()\n\n\n\n\n\n\nlcd.cursor()\n\n\nlcd_cursor()\n\n\n\n\n\n\nlcd.scrollDisplayLeft()\n\n\nlcd_scrollDisplayLeft()\n\n\n\n\n\n\nlcd.scrollDisplayRight()\n\n\nlcd_scrollDisplayRight()\n\n\n\n\n\n\nlcd.leftToRight()\n\n\nlcd_leftToRight()\n\n\n\n\n\n\nlcd.rightToLeft()\n\n\nlcd_rightToLeft()\n\n\n\n\n\n\nlcd.noAutoscroll()\n\n\nlcd_noAutoscroll()\n\n\n\n\n\n\nlcd.autoscroll()\n\n\nlcd_autoscroll()\n\n\n\n\n\n\nlcd.setRowOffsets(row0,row1,row2,row3)\n\n\nlcd_setRowOffsets(row0,row1,row2,row3)\n\n\n\n\n\n\nlcd.createChar(number, data[])\n\n\nlcd_createChar(number, data[])\n\n\n\n\n\n\nlcd.setCursor(col,row)\n\n\nlcd_setCursor(col,row)\n\n\n\n\n\n\nresult = lcd.write(value)\n\n\nresult = lcd_write(value)\n\n\n\n\n\n\nlcd.command(value)\n\n\nlcd_command(value)\n\n\n\n\n\n\n\n\nThe LCD interface mode can be changed at run time by calling the\n\nlcd_init(...)\n function.\n\n\nExample\n\n\nOutput some Text and count the time since the last reset. Notice the\nslightly different position of the opening parenthesis at the \"class\nconstructor\" function LiquidCrystal compared to the C++ instatiation.\n\n\n#include <Arduino.h>\n#include <LiquidCrystal.h>\n\n// initialize the library with the numbers of the interface pins\n// The instance name \"lcd\" is *within* the brackets\nLiquidCrystal (lcd,PA1,PA2, PA3,PD2,PD3,PD4);\n\nvoid setup() {\n  lcd_begin(16, 2);\n  lcd_print_s(\"hello, world!\");\n}\n\n\nvoid loop() {\n  lcd_setCursor(0, 1);\n  lcd_print_u(millis() / 1000);\n}\n\n\n\n\nCompare it to the original Arduino C++-Sytax:\n\n\n#include <LiquidCrystal.h>\n\n// initialize the library with the numbers of the interface pins\n// The instance name \"lcd\" is *before* the brackets\nLiquidCrystal lcd(12, 11, 5, 4, 3, 2);\n\nvoid setup() {\n  lcd.begin(16, 2);\n  lcd.print(\"hello, world!\");\n}\n\nvoid loop() {\n  lcd.setCursor(0, 1);\n  lcd.print(millis() / 1000);\n}\n\n\n\n\nPossible improvements\n\n\nThis is not a to-do-list, just brainstorming and a collection of random\nthoughts.\n\n\nDirect port access\n\n\nAs long as the pin numberings are known at compile time it would be possible\nuse direct port register access and the access pattern could be optimized if\nall data pins are on the same port.\n\n\nAuto-detect 4-bit mode\n\n\nThe parameter \nfourbitmode\n of the init() function/method is not needed. It\nwould be sufficient to check \nd5\n for a valid value. If it is not valid,\nassume 4-bit mode.\n\n\nAs init() is not called very frequently the possible advantage would be small\ncompared to the downside of breaking the Arduino compatibility.",
            "title": "LiquidCrystal character LCD library"
        },
        {
            "location": "/api/LiquidCrystal/#liquidcrystal-library",
            "text": "This library is for character LCDs based on the HD44780 controller.\nDerived from the Arduino LiquidCrystal library v1.8.0.",
            "title": "LiquidCrystal Library"
        },
        {
            "location": "/api/LiquidCrystal/#api",
            "text": "This library is a singleton library, it is not possible to use more than one\ninstance per sketch.  The API syntax is very similar to the original C++ syntax, thanks to some c preprocessor macro magic .  Apart from the usual name mangeling for polymorph functions (mostly the\ndifferent variants of the Print::print method) moving the opening bracket at\nthe class declarator line and replacing the dots in the method names for\nunderscores is all it needs.     Arduino syntax  sduino syntax      LiquidCrystal lcd(rs,en,d0,d1,d2,d3)  LiquidCrystal (lcd,rs,en,d0,d1,d2,d3)    LiquidCrystal lcd(rs,rw,en,d0,d1,d2,d3)  LiquidCrystal (lcd,rs,rw,en,d0,d1,d2,d3)    LiquidCrystal lcd(rs,en,d0,d1,d2,d3,d4,d5,d6,d7)  LiquidCrystal (lcd,rs,en,d0,d1,d2,d3,d4,d5,d6,d7)    LiquidCrystal lcd(rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7)  LiquidCrystal (lcd,rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7)    lcd.init(rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7)  lcd_init(mode,rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7)    lcd.begin(cols,lines)  lcd_begin(cols,lines)    lcd.begin(cols,lines,charsize)  lcd_begin_charsize(cols,lines,charsize)    lcd.clear()  lcd_clear()    lcd.home()  lcd_home()    lcd.noDisplay()  lcd_noDisplay()    lcd.display()  lcd_display()    lcd.noBlink()  lcd_noBlink()    lcd.blink()  lcd_blink()    lcd.noCursor()  lcd_noCursor()    lcd.cursor()  lcd_cursor()    lcd.scrollDisplayLeft()  lcd_scrollDisplayLeft()    lcd.scrollDisplayRight()  lcd_scrollDisplayRight()    lcd.leftToRight()  lcd_leftToRight()    lcd.rightToLeft()  lcd_rightToLeft()    lcd.noAutoscroll()  lcd_noAutoscroll()    lcd.autoscroll()  lcd_autoscroll()    lcd.setRowOffsets(row0,row1,row2,row3)  lcd_setRowOffsets(row0,row1,row2,row3)    lcd.createChar(number, data[])  lcd_createChar(number, data[])    lcd.setCursor(col,row)  lcd_setCursor(col,row)    result = lcd.write(value)  result = lcd_write(value)    lcd.command(value)  lcd_command(value)     The LCD interface mode can be changed at run time by calling the lcd_init(...)  function.",
            "title": "API"
        },
        {
            "location": "/api/LiquidCrystal/#example",
            "text": "Output some Text and count the time since the last reset. Notice the\nslightly different position of the opening parenthesis at the \"class\nconstructor\" function LiquidCrystal compared to the C++ instatiation.  #include <Arduino.h>\n#include <LiquidCrystal.h>\n\n// initialize the library with the numbers of the interface pins\n// The instance name \"lcd\" is *within* the brackets\nLiquidCrystal (lcd,PA1,PA2, PA3,PD2,PD3,PD4);\n\nvoid setup() {\n  lcd_begin(16, 2);\n  lcd_print_s(\"hello, world!\");\n}\n\n\nvoid loop() {\n  lcd_setCursor(0, 1);\n  lcd_print_u(millis() / 1000);\n}  Compare it to the original Arduino C++-Sytax:  #include <LiquidCrystal.h>\n\n// initialize the library with the numbers of the interface pins\n// The instance name \"lcd\" is *before* the brackets\nLiquidCrystal lcd(12, 11, 5, 4, 3, 2);\n\nvoid setup() {\n  lcd.begin(16, 2);\n  lcd.print(\"hello, world!\");\n}\n\nvoid loop() {\n  lcd.setCursor(0, 1);\n  lcd.print(millis() / 1000);\n}",
            "title": "Example"
        },
        {
            "location": "/api/LiquidCrystal/#possible-improvements",
            "text": "This is not a to-do-list, just brainstorming and a collection of random\nthoughts.  Direct port access  As long as the pin numberings are known at compile time it would be possible\nuse direct port register access and the access pattern could be optimized if\nall data pins are on the same port.  Auto-detect 4-bit mode  The parameter  fourbitmode  of the init() function/method is not needed. It\nwould be sufficient to check  d5  for a valid value. If it is not valid,\nassume 4-bit mode.  As init() is not called very frequently the possible advantage would be small\ncompared to the downside of breaking the Arduino compatibility.",
            "title": "Possible improvements"
        },
        {
            "location": "/api/PCD8544/",
            "text": "PCD8544 Library\n\n\nThis library is for monochrome graphical LCD based on the Philips PCD8544\ncontroller\n(\ndatasheet\n)\nor compatibles. These displays quite cheap and are commonly found on older monochrome mobile\nphones, such as the \nNokia 3310\n or\n\n5110\n.\n\n\nThis library is a very much simpified version of the Adafruit library.\n\n\n\n\nOptimized for a minimal memory footprint.\n\n\nOnly SPI mode supported. \n\n\nUses soft-SPI, does not need the SPI pins.\n\n\n\n\nThis is a modified version of the\n\nPCD8544 library\n written by\n\nCarlos Rodrigues\n. It is ported from C++ to C\nsyntax and is meant to be used with the sduino environment for the STM8.\n\n\nThis library is meant to have a minimal memory footprint. If you need\ngraphics and other features and can spare the resources, check out the\n\nlibrary\n\nfrom Adafruit (no sduino/STM8 port yet, though).\n\n\nAPI\n\n\nThanks to some \nc preprocessor macro magic\n the API syntax is\nvery similar to the original C++ syntax. Apart from the usual name mangeling\nfor polymorph functions replacing the dots in the method names for\nunderscores and a small modification of the initializer code should be\nenough. See below for an example.\n\n\nThe instantiation \"method\" can be called only one time per sketch as this\nlibrary is a singleton library. It is not possible to use more than one\ninstance per sketch.\n\n\n\n\n\n\n\n\nArduino syntax\n\n\nsduino syntax\n\n\n\n\n\n\n\n\n\n\nPCD8544 lcd\n\n\nno default pin mapping supported\n\n\n\n\n\n\nPCD8544 lcd(sclk,sdin,dc,reset,sce)\n\n\nPCD8544 (lcd,sclk,sdin,dc,reset,sce)\n\n\n\n\n\n\nlcd.begin()\n\n\nlcd_begin()\n\n\n\n\n\n\nlcd.begin(width,height)\n\n\nlcd_begin_wh(width,height)\n\n\n\n\n\n\nlcd.begin(width,height,chiptype)\n\n\nlcd_begin_full(width,height,chiptype)\n\n\n\n\n\n\nlcd.stop()\n\n\nlcd_stop()\n\n\n\n\n\n\nlcd.clear()\n\n\nlcd_clear()\n\n\n\n\n\n\nlcd.clearLine()\n\n\nlcd_clearLine()\n\n\n\n\n\n\nlcd.setPower(flag)\n\n\nlcd_setPower(flag)\n\n\n\n\n\n\nlcd.display()\n\n\nlcd_display()\n\n\n\n\n\n\nlcd.noDisplay()\n\n\nlcd_noDisplay()\n\n\n\n\n\n\nlcd.setInverse(flag)\n\n\nlcd_setInverse(flag)\n\n\n\n\n\n\nlcd.setContrast(level)\n\n\nlcd_setContrast(level)\n\n\n\n\n\n\nlcd.home()\n\n\nlcd_home()\n\n\n\n\n\n\nlcd.setCursor(col,line)\n\n\nlcd_setCursor(col,line)\n\n\n\n\n\n\nresult = lcd.write(value)\n\n\nresult = lcd_write(value)\n\n\n\n\n\n\nlcd.createChar(chr,glyph[])\n\n\nlcd_createChar(chr,glyph)\n\n\n\n\n\n\nlcd.drawBitmap(data[],columns,lines)\n\n\nlcd_drawBitmap(data[],columns,lines)\n\n\n\n\n\n\nlcd.drawColumn(lines, value)\n\n\nlcd.drawColumn(lines, value)\n\n\n\n\n\n\n\n\nThe default resolution of 84x48 fits the commons Nokia 5110 display.\n\n\nExample\n\n\n#include <PCD8544.h>\n\nPCD8544(lcd, PC5, PC6, PC4, PC7, PD1); // sclk,sdin,dc,reset,sce\n\nint counter = 0;\n\nvoid setup() {\n  lcd_begin();  // default resolution is 84x48\n}\n\n\nvoid loop() {\n  // Write some text on the first line...\n  lcd_setCursor(0, 0);\n  lcd_print_s(\"Hello, World!\");\n\n  // Write the counter on the second line...\n  lcd_setCursor(0, 1);\n  lcd_print_u(counter);\n\n  delay(200);\n  counter++;\n}\n\n\n\n\nHardware connections\n\n\nTo use this library, you must first connect your LCD to the proper pins on\nthe STM8 board. This library uses bitbanging for the SPI data transfer, so\nyou are not bound to the SPI pins for SCLK and MOSI.\n\n\nFor a Nokia 5510 display connected to a STM8S103 breakout board, the\nconnections look like this:\n\n\n\n\n\n\n\n\nDisplay Pin\n\n\nSTM8S breakout board\n\n\n\n\n\n\n\n\n\n\nPin 1 (VCC)\n\n\n+3.3V (marked by a square around the pin on the silkscreen)\n\n\n\n\n\n\nPin 2 (GND)\n\n\nGround\n\n\n\n\n\n\nPin 3 (SCE)\n\n\nSTM8S103 pin PD1 (sduino digital pin 10)\n\n\n\n\n\n\nPin 4 (RST)\n\n\nSTM8S103 pin PC7 (sduino digital pin 9)\n\n\n\n\n\n\nPin 5 (D/C)\n\n\nSTM8S103 pin PC4 (sduino digital pin 6)\n\n\n\n\n\n\nPin 6 (MOSI)\n\n\nSTM8S103 pin PC6 (sduino digital pin 8)\n\n\n\n\n\n\nPin 7 (SCLK)\n\n\nSTM8S103 pin PC5 (sduino digital pin 7)\n\n\n\n\n\n\nPin 8 (LED)\n\n\n82 Ohm resistor to 3.3V or 330 Ohm to 5V\n\n\n\n\n\n\n\n\nSince the STM8S works on 3.3V you can connect the data lines directly to\nport lines. If you are using this display with a 5V CPU (like on most\nArduino boards), you have to add extra components to connect it to the\ndigital pins of the Arduino (not necessary if you are using a 3.3V\nvariant of the Arduino, such as Sparkfun's Arduino Pro).\n\n\nThe background LEDs need only 2.8V/6mA. If you connect them to a port pin,\nprefer a HS (High sink) pin (see CPU datasheet, all pins except the\noscillator and the I2C pin PA1/PA2 and PB4/PB5). PWM pins are the best\nchoice.\n\n\nwhen soldering the pin connectors, keep in mind that the upside of the\ndisplay is the thicker part of the metal frame.\n\n\nFor a Nokia 3310 display the connections would be the following:\n\n\n\n\n\n\n\n\nDisplay Pin\n\n\nArduino Pin\n\n\n\n\n\n\n\n\n\n\nPin 1\n\n\n+3.3V Pin\n\n\n\n\n\n\nPin 2 (SCLK)\n\n\nPC5, digital Pin 7\n\n\n\n\n\n\nPin 3 (SDIN/MOSI)\n\n\nPC6, digital Pin 8\n\n\n\n\n\n\nPin 4 (D/C)\n\n\nPC4, digital Pin 6\n\n\n\n\n\n\nPin 5 (SCE)\n\n\nPD1, digital Pin 10\n\n\n\n\n\n\nPin 6\n\n\nGround Pin\n\n\n\n\n\n\nPin 7\n\n\n10uF capacitor to Ground Pin\n\n\n\n\n\n\nPin 8 (RST)\n\n\nPC7, digital Pin 9\n\n\n\n\n\n\n\n\nFor this display model, \"Pin 1\" is the leftmost pin when facing the back of\nthe display with the connector on top.\n\n\nCustom Symbols\n\n\nThe library allows the use of custom bitmap symbols (5x8), defined by an\narray of five bytes. Checkout the examples in the library folder for usage\nof this function.\n\n\nTo make it easy to create custom symbols, there's a\ngraphical glyph editor \navailable online\n.",
            "title": "PCD8544 libray for Nokia 5110-like graphical LCDs"
        },
        {
            "location": "/api/PCD8544/#pcd8544-library",
            "text": "This library is for monochrome graphical LCD based on the Philips PCD8544\ncontroller\n( datasheet )\nor compatibles. These displays quite cheap and are commonly found on older monochrome mobile\nphones, such as the  Nokia 3310  or 5110 .  This library is a very much simpified version of the Adafruit library.   Optimized for a minimal memory footprint.  Only SPI mode supported.   Uses soft-SPI, does not need the SPI pins.   This is a modified version of the PCD8544 library  written by Carlos Rodrigues . It is ported from C++ to C\nsyntax and is meant to be used with the sduino environment for the STM8.  This library is meant to have a minimal memory footprint. If you need\ngraphics and other features and can spare the resources, check out the library \nfrom Adafruit (no sduino/STM8 port yet, though).",
            "title": "PCD8544 Library"
        },
        {
            "location": "/api/PCD8544/#api",
            "text": "Thanks to some  c preprocessor macro magic  the API syntax is\nvery similar to the original C++ syntax. Apart from the usual name mangeling\nfor polymorph functions replacing the dots in the method names for\nunderscores and a small modification of the initializer code should be\nenough. See below for an example.  The instantiation \"method\" can be called only one time per sketch as this\nlibrary is a singleton library. It is not possible to use more than one\ninstance per sketch.     Arduino syntax  sduino syntax      PCD8544 lcd  no default pin mapping supported    PCD8544 lcd(sclk,sdin,dc,reset,sce)  PCD8544 (lcd,sclk,sdin,dc,reset,sce)    lcd.begin()  lcd_begin()    lcd.begin(width,height)  lcd_begin_wh(width,height)    lcd.begin(width,height,chiptype)  lcd_begin_full(width,height,chiptype)    lcd.stop()  lcd_stop()    lcd.clear()  lcd_clear()    lcd.clearLine()  lcd_clearLine()    lcd.setPower(flag)  lcd_setPower(flag)    lcd.display()  lcd_display()    lcd.noDisplay()  lcd_noDisplay()    lcd.setInverse(flag)  lcd_setInverse(flag)    lcd.setContrast(level)  lcd_setContrast(level)    lcd.home()  lcd_home()    lcd.setCursor(col,line)  lcd_setCursor(col,line)    result = lcd.write(value)  result = lcd_write(value)    lcd.createChar(chr,glyph[])  lcd_createChar(chr,glyph)    lcd.drawBitmap(data[],columns,lines)  lcd_drawBitmap(data[],columns,lines)    lcd.drawColumn(lines, value)  lcd.drawColumn(lines, value)     The default resolution of 84x48 fits the commons Nokia 5110 display.",
            "title": "API"
        },
        {
            "location": "/api/PCD8544/#example",
            "text": "#include <PCD8544.h>\n\nPCD8544(lcd, PC5, PC6, PC4, PC7, PD1); // sclk,sdin,dc,reset,sce\n\nint counter = 0;\n\nvoid setup() {\n  lcd_begin();  // default resolution is 84x48\n}\n\n\nvoid loop() {\n  // Write some text on the first line...\n  lcd_setCursor(0, 0);\n  lcd_print_s(\"Hello, World!\");\n\n  // Write the counter on the second line...\n  lcd_setCursor(0, 1);\n  lcd_print_u(counter);\n\n  delay(200);\n  counter++;\n}",
            "title": "Example"
        },
        {
            "location": "/api/PCD8544/#hardware-connections",
            "text": "To use this library, you must first connect your LCD to the proper pins on\nthe STM8 board. This library uses bitbanging for the SPI data transfer, so\nyou are not bound to the SPI pins for SCLK and MOSI.  For a Nokia 5510 display connected to a STM8S103 breakout board, the\nconnections look like this:     Display Pin  STM8S breakout board      Pin 1 (VCC)  +3.3V (marked by a square around the pin on the silkscreen)    Pin 2 (GND)  Ground    Pin 3 (SCE)  STM8S103 pin PD1 (sduino digital pin 10)    Pin 4 (RST)  STM8S103 pin PC7 (sduino digital pin 9)    Pin 5 (D/C)  STM8S103 pin PC4 (sduino digital pin 6)    Pin 6 (MOSI)  STM8S103 pin PC6 (sduino digital pin 8)    Pin 7 (SCLK)  STM8S103 pin PC5 (sduino digital pin 7)    Pin 8 (LED)  82 Ohm resistor to 3.3V or 330 Ohm to 5V     Since the STM8S works on 3.3V you can connect the data lines directly to\nport lines. If you are using this display with a 5V CPU (like on most\nArduino boards), you have to add extra components to connect it to the\ndigital pins of the Arduino (not necessary if you are using a 3.3V\nvariant of the Arduino, such as Sparkfun's Arduino Pro).  The background LEDs need only 2.8V/6mA. If you connect them to a port pin,\nprefer a HS (High sink) pin (see CPU datasheet, all pins except the\noscillator and the I2C pin PA1/PA2 and PB4/PB5). PWM pins are the best\nchoice.  when soldering the pin connectors, keep in mind that the upside of the\ndisplay is the thicker part of the metal frame.  For a Nokia 3310 display the connections would be the following:     Display Pin  Arduino Pin      Pin 1  +3.3V Pin    Pin 2 (SCLK)  PC5, digital Pin 7    Pin 3 (SDIN/MOSI)  PC6, digital Pin 8    Pin 4 (D/C)  PC4, digital Pin 6    Pin 5 (SCE)  PD1, digital Pin 10    Pin 6  Ground Pin    Pin 7  10uF capacitor to Ground Pin    Pin 8 (RST)  PC7, digital Pin 9     For this display model, \"Pin 1\" is the leftmost pin when facing the back of\nthe display with the connector on top.",
            "title": "Hardware connections"
        },
        {
            "location": "/api/PCD8544/#custom-symbols",
            "text": "The library allows the use of custom bitmap symbols (5x8), defined by an\narray of five bytes. Checkout the examples in the library folder for usage\nof this function.  To make it easy to create custom symbols, there's a\ngraphical glyph editor  available online .",
            "title": "Custom Symbols"
        },
        {
            "location": "/api/Mini_SSD1306/",
            "text": "Mini_SSD1306\n\n\nThis is a library for monochrome OLEDs based on SSD1306 drivers.\n\n\nThis library is a stripped-down version of the original\n\nAdafruit_SSD1306 library\n\nv1.1.2.\nThis version of the library does not depend on the Adafruit_GFX library and\nhas a \nmuch\n smaller memory footprint than the full version, but most of the\ngraphical features are missing.\n\n\nThe Library only supports I2C communication.\n\n\nAPI\n\n\nSSD1306(instancename, pin_reset);\n\nvoid Mini_SSD1306_begin(uint8_t switchvcc, uint8_t i2caddr, bool reset);\nvoid Mini_SSD1306_clearDisplay(void);\nvoid Mini_SSD1306_invertDisplay(uint8_t i);\nvoid Mini_SSD1306_display();\nvoid Mini_SSD1306_startscrollright(uint8_t start, uint8_t stop);\nvoid Mini_SSD1306_startscrollleft(uint8_t start, uint8_t stop);\nvoid Mini_SSD1306_startscrolldiagright(uint8_t start, uint8_t stop);\nvoid Mini_SSD1306_startscrolldiagleft(uint8_t start, uint8_t stop);\nvoid Mini_SSD1306_stopscroll(void);\nvoid Mini_SSD1306_dim(boolean dim);\nvoid Mini_SSD1306_drawPixel(int16_t x, int16_t y, uint8_t color);\n\n\n\n\nExample\n\n\nThe library initializes the display buffer with the Adafruit splash screen.\nSince it is not modified, \noled_display()\n shows it. The loop draws a\npattern of blinking pixels in an 8x8 grid:\n\n\n#include \"I2C.h\"\n#include \"Mini_SSD1306.h\"\n\nMini_SSD1306(oled,-1);  // -1 means no reset pin\n\n#if (SSD1306_LCDHEIGHT != 64)\n#error(\"Height incorrect, please fix Mini_SSD1306.h!\");\n#endif\n\nvoid setup()\n{\n    // Initialize with the I2C addr 0x3C. Some displays use 0x3D instead.\n    oled_begin(SSD1306_SWITCHCAPVCC, 0x3C,0);\n}\n\nvoid loop()\n{\n    uint8_t x,y;\n\n    oled_display(); // show the display buffer\n    delay (1000);\n\n    // draw some dots in an 8x8 pattern\n    for (x=0; x<WIDTH; x+=8)\n    {\n        for (y=0; y<HEIGHT-8; y+=8) // don't alter the stack!\n        {\n            oled_drawPixel(x,y,INVERSE);\n        }\n    }\n}\n\n\n\n\nHardware requirements\n\n\nThese tiny displays communicate usually via I2C, but SPI version do exist.\nMy display uses the I2C address 0x3C, but there are similar displays out\nthere configured to use the address 0x3D.\n\n\nThe display content has to be kept in memory as it is not possible to read\nthe memory content of the physical display. For 128x64 pixel this requires\n1kB of RAM. For low-memory devices like the STM8S103 it means the display\nbuffer overlaps with the stack. Notice the chaotic pattern in the lower part\nof the screen:\n\n\n\n\nTechnical data:\n  * Driver chip SSD1306\n  * Display resolution: 128x64\n  * Power: 3.3V, approx. 20mA (5V possible)\n  * Interface: I2C, some modules support SPI as well\n  * I2C-Address: 0x3c, configurable to 0x3d by setting a solder bridge (on\n    some modules)\n\n\nPin out of an I2C module:\n\n\n\n\n\n\n\n\nPin\n\n\nFunction\n\n\nSTM8S103 pin\n\n\nsduino pin\n\n\n\n\n\n\n\n\n\n\n1\n\n\nGND\n\n\n\n\n\n\n\n\n\n\n2\n\n\nVcc\n\n\n\n\n\n\n\n\n\n\n3\n\n\nSCL\n\n\nPB4\n\n\nPIN_WIRE_SCL, SCL, 4\n\n\n\n\n\n\n4\n\n\nSDA\n\n\nPB5\n\n\nPIN_WIRE_SDA, SDA, 3\n\n\n\n\n\n\n\n\nFurther reading\n\n\nTechnical information:\n  * Adafruit tutorial: https://learn.adafruit.com/monochrome-oled-breakouts\n  * SSD1306 datasheet: https://www.adafruit.com/datasheets/SSD1306.pdf\n\n\nOther libraries:\n  * Adafruit library: https://github.com/adafruit/Adafruit_SSD1306\n  * Old Arduino library u8glib: https://github.com/olikraus/u8glib\n  * newer library u8g2: https://github.com/olikraus/u8g2\n\n\nPossible improvements\n\n\nFaster I2C transfer\n\n\nFaster I2C transfer is supported by the \nI2C.html\n, but to use\nit you have to modify the source code for the Mini_SSD1306 library. Make\nthis configurable in the instantiation function.",
            "title": "Mini_SSD1306 library for monochrome OLED-displays"
        },
        {
            "location": "/api/Mini_SSD1306/#mini_ssd1306",
            "text": "This is a library for monochrome OLEDs based on SSD1306 drivers.  This library is a stripped-down version of the original Adafruit_SSD1306 library \nv1.1.2.\nThis version of the library does not depend on the Adafruit_GFX library and\nhas a  much  smaller memory footprint than the full version, but most of the\ngraphical features are missing.  The Library only supports I2C communication.",
            "title": "Mini_SSD1306"
        },
        {
            "location": "/api/Mini_SSD1306/#api",
            "text": "SSD1306(instancename, pin_reset);\n\nvoid Mini_SSD1306_begin(uint8_t switchvcc, uint8_t i2caddr, bool reset);\nvoid Mini_SSD1306_clearDisplay(void);\nvoid Mini_SSD1306_invertDisplay(uint8_t i);\nvoid Mini_SSD1306_display();\nvoid Mini_SSD1306_startscrollright(uint8_t start, uint8_t stop);\nvoid Mini_SSD1306_startscrollleft(uint8_t start, uint8_t stop);\nvoid Mini_SSD1306_startscrolldiagright(uint8_t start, uint8_t stop);\nvoid Mini_SSD1306_startscrolldiagleft(uint8_t start, uint8_t stop);\nvoid Mini_SSD1306_stopscroll(void);\nvoid Mini_SSD1306_dim(boolean dim);\nvoid Mini_SSD1306_drawPixel(int16_t x, int16_t y, uint8_t color);",
            "title": "API"
        },
        {
            "location": "/api/Mini_SSD1306/#example",
            "text": "The library initializes the display buffer with the Adafruit splash screen.\nSince it is not modified,  oled_display()  shows it. The loop draws a\npattern of blinking pixels in an 8x8 grid:  #include \"I2C.h\"\n#include \"Mini_SSD1306.h\"\n\nMini_SSD1306(oled,-1);  // -1 means no reset pin\n\n#if (SSD1306_LCDHEIGHT != 64)\n#error(\"Height incorrect, please fix Mini_SSD1306.h!\");\n#endif\n\nvoid setup()\n{\n    // Initialize with the I2C addr 0x3C. Some displays use 0x3D instead.\n    oled_begin(SSD1306_SWITCHCAPVCC, 0x3C,0);\n}\n\nvoid loop()\n{\n    uint8_t x,y;\n\n    oled_display(); // show the display buffer\n    delay (1000);\n\n    // draw some dots in an 8x8 pattern\n    for (x=0; x<WIDTH; x+=8)\n    {\n        for (y=0; y<HEIGHT-8; y+=8) // don't alter the stack!\n        {\n            oled_drawPixel(x,y,INVERSE);\n        }\n    }\n}",
            "title": "Example"
        },
        {
            "location": "/api/Mini_SSD1306/#hardware-requirements",
            "text": "These tiny displays communicate usually via I2C, but SPI version do exist.\nMy display uses the I2C address 0x3C, but there are similar displays out\nthere configured to use the address 0x3D.  The display content has to be kept in memory as it is not possible to read\nthe memory content of the physical display. For 128x64 pixel this requires\n1kB of RAM. For low-memory devices like the STM8S103 it means the display\nbuffer overlaps with the stack. Notice the chaotic pattern in the lower part\nof the screen:   Technical data:\n  * Driver chip SSD1306\n  * Display resolution: 128x64\n  * Power: 3.3V, approx. 20mA (5V possible)\n  * Interface: I2C, some modules support SPI as well\n  * I2C-Address: 0x3c, configurable to 0x3d by setting a solder bridge (on\n    some modules)  Pin out of an I2C module:     Pin  Function  STM8S103 pin  sduino pin      1  GND      2  Vcc      3  SCL  PB4  PIN_WIRE_SCL, SCL, 4    4  SDA  PB5  PIN_WIRE_SDA, SDA, 3",
            "title": "Hardware requirements"
        },
        {
            "location": "/api/Mini_SSD1306/#further-reading",
            "text": "Technical information:\n  * Adafruit tutorial: https://learn.adafruit.com/monochrome-oled-breakouts\n  * SSD1306 datasheet: https://www.adafruit.com/datasheets/SSD1306.pdf  Other libraries:\n  * Adafruit library: https://github.com/adafruit/Adafruit_SSD1306\n  * Old Arduino library u8glib: https://github.com/olikraus/u8glib\n  * newer library u8g2: https://github.com/olikraus/u8g2",
            "title": "Further reading"
        },
        {
            "location": "/api/Mini_SSD1306/#possible-improvements",
            "text": "Faster I2C transfer  Faster I2C transfer is supported by the  I2C.html , but to use\nit you have to modify the source code for the Mini_SSD1306 library. Make\nthis configurable in the instantiation function.",
            "title": "Possible improvements"
        },
        {
            "location": "/api/Stepper/",
            "text": "Stepper Library\n\n\nA Library for driving stepper motors with 2, 4 or 5 phases.\nDerived from the Arduino Stepper library v1.8.0.\n\n\nAPI\n\n\nThis library is a multi-instance library, it supports an arbitrary number of\nstepper motors per sketch.\n\n\nThe API syntax is very similar to the original C++ syntax, thanks to some\n\nc preprocessor macro magic\n.\n\n\nThe declaration supports polymorphism, so all that is needed to adopt an\nexisting sketch for use with sduino is moving the opening bracket at\nthe class declarator line and replacing the dots in the method names for\nunderscores.\n\n\n\n\n\n\n\n\nArduino method\n\n\nsduino function\n\n\n\n\n\n\n\n\n\n\nStepper myStepper(steps, pin1,pin2);\n\n\nStepper (myStepper,steps,pin1,pin2);\n\n\n\n\n\n\nStepper myStepper(steps, pin1,pin2,pin3,pin4);\n\n\nStepper (myStepper,steps,pin1,pin2,pin3,pin4);\n\n\n\n\n\n\nStepper myStepper(steps, pin1,pin2,pin3,pin4,pin5);\n\n\nStepper (myStepper,steps,pin1,pin2,pin3,pin4,pin5);\n\n\n\n\n\n\nmyStepper.setSpeed(speed);\n\n\nmyStepper_setSpeed(speed);\n\n\n\n\n\n\nmyStepper.step(n);\n\n\nmyStepper_step(n);\n\n\n\n\n\n\nmyStepper.version();\n\n\nmyStepper_version();\n\n\n\n\n\n\n\n\nAPI additions\n\n\nThe sduino implementation adds some extra methods to the stock Stepper\nlibrary to allow to work arounds some limitations of C code vs. C++:\n\n\n\n\n\n\n\n\nArduino method\n\n\nsduino function\n\n\n\n\n\n\n\n\n\n\ndone automatically on start up\n\n\nmyStepper_activateOutputs();\n\n\n\n\n\n\nnot impemented\n\n\nmyStepper_2phase(steps,pin1,pin2);\n\n\n\n\n\n\nnot impemented\n\n\nmyStepper_4phase(steps,pin1,pin2,pin3,pin4);\n\n\n\n\n\n\nnot impemented\n\n\nmyStepper_5phase(steps,pin1,pin2,pin3,pin4,pin5);\n\n\n\n\n\n\n\n\nInitializing the output pins on demand\n\n\nIn real C++ the internal class constructor method initializes the motor pins\nto output mode automatically at start up of the programm. In C this doesn't\nhappen automatically. Most libraries implement a begin() method for exactly\nthis purpose, but this one does not include an explicit constructor method.\n\n\nInstead, the output mode is set automatically right before the very first\nmotor step. This means that the driver pins stay uninitialized and are left\nfloating from the time of power up until the first step is requested. This\nwon't be a problem in most cases as most motor drivers are using pull-up or\npull-down resistors to ensure proper signal levels.\n\n\nIf needed, the application could call the added \nactivateOutputs()\n method\nin the setup() function to force an immediate port pin initialization:\n\n\nsetup() {\n  myStepper_activateOutputs();    // initializes the motor pins to output mode\n}\n\n\n\n\nAssigning the pin connections at run time\n\n\nThe way the instantiation macro works requires compile-time constant values\nfor all parameters (see below in section 'Implementation Details'). In order\nto be able to (re-) configure the pin connections at run time this version\nof the library implements the functions \n2phase()\n, \n4phase()\n and\n\n5phase()\n. These functions act like a constructor and allow for full\nre-initialisation of an already existing \"object\".\n\n\nIf you need to (re-) configure the pin connections at run time (e.g. read it\nfrom a configuration EEPROM first) you can initialize a data structure with\n\n0\n for the unknown pin numbers and set them later by calling the right\nxphase()-function:\n\n\nStepper (myStepper,0,0);\n\nsetup() {\n    ... figure out the pin numbers somehow ...\n    myStepper_4phase(stepsPerRev, pin1, pin2, pin3, pin4);\n    ...\n}\n\nloop () {\n    ...\n    myStepper_setSpeed(60);\n    myStepper_step(100);\n    ...\n}\n\n\n\n\n\n5 phase support can be deactivated to save code space\n\n\n5 phase motors are not very common, but supporting them increases the code\nsize significantly. By defining the compiler flag NO_5PHASE it is possible\nto deactivate the support for 5 phase motors. This saves 736 bytes of code\nspace. Add this line to your Makefile if you don't need 5 phase support:\n\n\nCFLAGS = -DNO_5PHASE\n\n\n\n\nExample\n\n\nNotice the slightly different position of the opening parenthesis at the\n\"class constructor\" 'function' Stepper compared to the C++ instantiation.\n(available in the examples folder as \nstepper_oneRevolution.c\n)\n\n\nC-Version for use with sduino:\n\n\n#include <Arduino.h>\n#include <Stepper.h>\n\n// change this to fit the number of steps per revolution for your motor\n#define stepsPerRevolution 200\n\n// initialize the stepper library on pins 8 through 11:\nStepper (myStepper,stepsPerRevolution, 8, 9, 10, 11);\n\nvoid setup() {\n  // set the speed at 60 rpm:\n  myStepper_setSpeed(60);\n}\n\nvoid loop() {\n  // step one revolution  in one direction:\n  myStepper_step(stepsPerRevolution);\n  delay(500);\n\n  // step one revolution in the other direction:\n  myStepper_step(-stepsPerRevolution);\n  delay(500);\n}\n\n\n\n\nOriginal Arduino C++-Sytax:\n\n\n#include <Stepper.h>\n\nconst int stepsPerRevolution = 200;  // change this to fit the number of steps per revolution\n// for your motor\n\n// initialize the stepper library on pins 8 through 11:\nStepper myStepper(stepsPerRevolution, 8, 9, 10, 11);\n\nvoid setup() {\n  // set the speed at 60 rpm:\n  myStepper.setSpeed(60);\n}\n\nvoid loop() {\n  // step one revolution  in one direction:\n  myStepper.step(stepsPerRevolution);\n  delay(500);\n\n  // step one revolution in the other direction:\n  myStepper.step(-stepsPerRevolution);\n  delay(500);\n}\n\n\n\n\nImplementation details\n\n\nTechnically, each Stepper instance is represented by a file-descriptor-like\nstructure. This structure is initialized by the instantiation macro\n\nStepper\n. This means that all values are required to be constant values,\nknown at compile time. A \nconst\n qualifier is not enough for SDCC, it\nrequires either a \n#define\n or an \nenum\n:\n\n\nconst int numOfSteps = 1;   // does not work with SDCC\n#define MotorPin1  10       // ok, works\nenum { MotorPin2 = 11 };    // ok, works\n\nStepper (myStepper, numOfSteps, MotorPin1, MotorPin2);\n\n\n\n\nAll functions require a pointer to the stepper data structur as their first\nargument to identify the stepper instance. All this pointer handling is\nhidden by preprocessor magic, but it is still real and pure C. If you\ninsist, you can still call the 'real' functions yourself (but you gain\nnothing, the compiler produces exactly the same output).\n\n\nPossible impovements\n\n\nThis is not a to-do-list, just brainstorming and a collection of random\nthoughts.\n\n\nNothing yet.",
            "title": "Stepper library"
        },
        {
            "location": "/api/Stepper/#stepper-library",
            "text": "A Library for driving stepper motors with 2, 4 or 5 phases.\nDerived from the Arduino Stepper library v1.8.0.",
            "title": "Stepper Library"
        },
        {
            "location": "/api/Stepper/#api",
            "text": "This library is a multi-instance library, it supports an arbitrary number of\nstepper motors per sketch.  The API syntax is very similar to the original C++ syntax, thanks to some c preprocessor macro magic .  The declaration supports polymorphism, so all that is needed to adopt an\nexisting sketch for use with sduino is moving the opening bracket at\nthe class declarator line and replacing the dots in the method names for\nunderscores.     Arduino method  sduino function      Stepper myStepper(steps, pin1,pin2);  Stepper (myStepper,steps,pin1,pin2);    Stepper myStepper(steps, pin1,pin2,pin3,pin4);  Stepper (myStepper,steps,pin1,pin2,pin3,pin4);    Stepper myStepper(steps, pin1,pin2,pin3,pin4,pin5);  Stepper (myStepper,steps,pin1,pin2,pin3,pin4,pin5);    myStepper.setSpeed(speed);  myStepper_setSpeed(speed);    myStepper.step(n);  myStepper_step(n);    myStepper.version();  myStepper_version();     API additions  The sduino implementation adds some extra methods to the stock Stepper\nlibrary to allow to work arounds some limitations of C code vs. C++:     Arduino method  sduino function      done automatically on start up  myStepper_activateOutputs();    not impemented  myStepper_2phase(steps,pin1,pin2);    not impemented  myStepper_4phase(steps,pin1,pin2,pin3,pin4);    not impemented  myStepper_5phase(steps,pin1,pin2,pin3,pin4,pin5);     Initializing the output pins on demand  In real C++ the internal class constructor method initializes the motor pins\nto output mode automatically at start up of the programm. In C this doesn't\nhappen automatically. Most libraries implement a begin() method for exactly\nthis purpose, but this one does not include an explicit constructor method.  Instead, the output mode is set automatically right before the very first\nmotor step. This means that the driver pins stay uninitialized and are left\nfloating from the time of power up until the first step is requested. This\nwon't be a problem in most cases as most motor drivers are using pull-up or\npull-down resistors to ensure proper signal levels.  If needed, the application could call the added  activateOutputs()  method\nin the setup() function to force an immediate port pin initialization:  setup() {\n  myStepper_activateOutputs();    // initializes the motor pins to output mode\n}  Assigning the pin connections at run time  The way the instantiation macro works requires compile-time constant values\nfor all parameters (see below in section 'Implementation Details'). In order\nto be able to (re-) configure the pin connections at run time this version\nof the library implements the functions  2phase() ,  4phase()  and 5phase() . These functions act like a constructor and allow for full\nre-initialisation of an already existing \"object\".  If you need to (re-) configure the pin connections at run time (e.g. read it\nfrom a configuration EEPROM first) you can initialize a data structure with 0  for the unknown pin numbers and set them later by calling the right\nxphase()-function:  Stepper (myStepper,0,0);\n\nsetup() {\n    ... figure out the pin numbers somehow ...\n    myStepper_4phase(stepsPerRev, pin1, pin2, pin3, pin4);\n    ...\n}\n\nloop () {\n    ...\n    myStepper_setSpeed(60);\n    myStepper_step(100);\n    ...\n}  5 phase support can be deactivated to save code space  5 phase motors are not very common, but supporting them increases the code\nsize significantly. By defining the compiler flag NO_5PHASE it is possible\nto deactivate the support for 5 phase motors. This saves 736 bytes of code\nspace. Add this line to your Makefile if you don't need 5 phase support:  CFLAGS = -DNO_5PHASE",
            "title": "API"
        },
        {
            "location": "/api/Stepper/#example",
            "text": "Notice the slightly different position of the opening parenthesis at the\n\"class constructor\" 'function' Stepper compared to the C++ instantiation.\n(available in the examples folder as  stepper_oneRevolution.c )  C-Version for use with sduino:  #include <Arduino.h>\n#include <Stepper.h>\n\n// change this to fit the number of steps per revolution for your motor\n#define stepsPerRevolution 200\n\n// initialize the stepper library on pins 8 through 11:\nStepper (myStepper,stepsPerRevolution, 8, 9, 10, 11);\n\nvoid setup() {\n  // set the speed at 60 rpm:\n  myStepper_setSpeed(60);\n}\n\nvoid loop() {\n  // step one revolution  in one direction:\n  myStepper_step(stepsPerRevolution);\n  delay(500);\n\n  // step one revolution in the other direction:\n  myStepper_step(-stepsPerRevolution);\n  delay(500);\n}  Original Arduino C++-Sytax:  #include <Stepper.h>\n\nconst int stepsPerRevolution = 200;  // change this to fit the number of steps per revolution\n// for your motor\n\n// initialize the stepper library on pins 8 through 11:\nStepper myStepper(stepsPerRevolution, 8, 9, 10, 11);\n\nvoid setup() {\n  // set the speed at 60 rpm:\n  myStepper.setSpeed(60);\n}\n\nvoid loop() {\n  // step one revolution  in one direction:\n  myStepper.step(stepsPerRevolution);\n  delay(500);\n\n  // step one revolution in the other direction:\n  myStepper.step(-stepsPerRevolution);\n  delay(500);\n}",
            "title": "Example"
        },
        {
            "location": "/api/Stepper/#implementation-details",
            "text": "Technically, each Stepper instance is represented by a file-descriptor-like\nstructure. This structure is initialized by the instantiation macro Stepper . This means that all values are required to be constant values,\nknown at compile time. A  const  qualifier is not enough for SDCC, it\nrequires either a  #define  or an  enum :  const int numOfSteps = 1;   // does not work with SDCC\n#define MotorPin1  10       // ok, works\nenum { MotorPin2 = 11 };    // ok, works\n\nStepper (myStepper, numOfSteps, MotorPin1, MotorPin2);  All functions require a pointer to the stepper data structur as their first\nargument to identify the stepper instance. All this pointer handling is\nhidden by preprocessor magic, but it is still real and pure C. If you\ninsist, you can still call the 'real' functions yourself (but you gain\nnothing, the compiler produces exactly the same output).",
            "title": "Implementation details"
        },
        {
            "location": "/api/Stepper/#possible-impovements",
            "text": "This is not a to-do-list, just brainstorming and a collection of random\nthoughts.  Nothing yet.",
            "title": "Possible impovements"
        },
        {
            "location": "/api/Servo/",
            "text": "Servo Library\n\n\nThis library can control a great number of servos. It makes careful use\nof timers: the library can control 12 servos using only 1 timer.\nDerived from the Arduino Servo library v1.8.0.\n\n\nThis library has a slightly diffent user interface than the usual singleton\nlibraries. This allows for handling more than one servo per Sketch but it\nrequires some more attention when porting an existing sketch from C++ to C.\n\n\nEach Servo instance is identified by a channel-ID. In order to match the C++\nclass constructor syntax it is defined as a type \nServo\n.\n\n\nThis channel-ID is used as a file-descriptor-like value and need to be\npassed to all API functions except for \nServo_attach()\n. This function\nclaimes the next free channel number.\n\n\nExample\n\n\nRead a potentiometer on analog input 0 and set a servo pulse length between\n1000us and 2023us:\n\n\n#include <Arduino.h>\n#include <Servo.h>\n\nServo myservo;          // just a simple unsigned char to hold the channel-ID\n\nint val;                // variable to read the value from the analog pin\n\nvoid setup() {\n  myservo = Servo_attach(9);    // attaches the servo on pin 9, returns channel-ID\n}\n\nvoid loop() {\n  val = analogRead(0);          // reads the value of the potentiometer\n  Servo_write(myservo, val+1000);// sets the servo position\n  delay(15);\n}\n\n\n\n\nOriginal Arduino C++-Sytax:\n\n\n#include <Servo.h>\n\nServo myservo;          // create servo object to control a servo\n\nint val;                // variable to read the value from the analog pin\n\nvoid setup() {\n  myservo.attach(9);    // attaches the servo on pin 9 to the servo object\n}\n\nvoid loop() {\n  val = analogRead(0);          // reads the value of the potentiometer\n  myservo.write(val+1000);      // sets the servo position\n  delay(15);\n}\n\n\n\n\n\nAPI\n\n\ndata type \nServo\n: A type definition for a simple unsigned char to hold the\nchannel number returned my \nServo_attach()\n. Needed for every servo. Syntax\nidentical to the Arduino class constructor.\n\n\n\n\n\n\n\n\nArduino syntax\n\n\nsduino syntax\n\n\n\n\n\n\n\n\n\n\nServo myservo;\n\n\nServo myservo;\n\n\n\n\n\n\nmyservo.attach(pin);\n\n\nmyservo = Servo_attach(pin);\n\n\n\n\n\n\nmyservo.attach(pin,min,max);\n\n\nServo_attach_minmax(pin,min,max);\n\n\n\n\n\n\nmyservo.detach();\n\n\nServo_detach(byte channel);\n\n\n\n\n\n\nmyservo.write(val);\n\n\nServo_write(myservo, val);\n\n\n\n\n\n\nmyservo.writeMicroseconds(val);\n\n\nServo_writeMicroseconds(myservo, val);\n\n\n\n\n\n\nval = myservo.read();\n\n\nval = Servo_read(myservo);\n\n\n\n\n\n\nval = myservo.readMicroseconds();\n\n\nval = Servo_readMicroseconds(myservo);\n\n\n\n\n\n\nmyservo.attached()\n\n\nServo_attached(myservo);\n\n\n\n\n\n\n\n\nuint8_t Servo_attach(int pin);\n\nattach the given pin to the next free channel, sets pinMode, returns channel\nnumber or 0 if failure.\n\n\nuint8_t Servo_attach_minmax(int pin, int min, int max);\n\nas above but also sets min and max values for writes. \n\n\nvoid Servo_detach(byte channel);\n\n\nvoid Servo_write(byte channel, int value);\n if value is < 200 it is treated\nas an angle and scaled according the minimum and maximum pulsewidth defined\nusing the attach() function earlier, otherwise as pulse width in\nmicroseconds, unscaled.\n\n\nvoid Servo_writeMicroseconds(byte channel, int value);\n\nWrite pulse width in microseconds, unscaled.\n\n\nint Servo_read(byte channel);\n\nreturns current pulse width as an angle between 0 and 180 degrees.\n\n\nint Servo_readMicroseconds(byte channel);\n\nreturns current pulse width in microseconds for this servo (was read_us() in\nfirst Arduino release).\n\n\nbool Servo_attached(byte channel);\n\nreturn true if this servo is attached, otherwise false .\n\n\nRelationship between PWM/analog output and Servo output\n\n\nIt is not possible to use a timer for PWM and the Servo Library at the same\ntime. Since this library currently uses timer1, the PWM function\n(\nanalogWrite()\n) is disabled for the pins connected to timer1 (for the\nSTM8S103 this is pin PC3 and PC4 or digital pin 5 and 6).\n\n\nPins connected to timer2 (PA3, PD3, PD4, digital pin 2,12,13) are still\nusable for PWM output.\n\n\nPossible improvements\n\n\nA more sophisticated pseudo-OO API\n\n\nDefine a set of preprocessor macros that more OO-like definitions like this\nbecome possible:\n\n\n\n\n\n\n\n\nCurrent syntax\n\n\nOO-like syntax\n\n\nArduino syntax\n\n\n\n\n\n\n\n\n\n\nmyservo = Servo_attach(pin);\n\n\nmyservo_attach(pin);\n\n\nmyservo.attach(pin);\n\n\n\n\n\n\nServo_write(myservo, val);\n\n\nmyservo_write(val);\n\n\nmyservo_write(val);\n\n\n\n\n\n\nval = Servo_read(myservo);\n\n\nval = myservo_read();\n\n\nval = myservo_read();\n\n\n\n\n\n\n\n\nOptimizing the handle_interrupts() function\n\n\nSDCC compiles this function very inefficiently. The code size is around 500\nBytes, and it is executed as part of the CC interrupt routine. Expected CPU\nload for a full servo group of 12 servos is approx. 2%.\n\n\n(Calculated for 16MHz CPU clock, 13 interrupts every 20ms = 650\ninterrupts/sec, approx. 500 clock cycles each)\n\n\nUsing more than one CC channel per timer\n\n\nit might be possible to use all capture+compare (CC) channels of one timer\nat the same time, attaching one servo group to each CC-channel. This way it\nwould be possible to serve up to 48 servos using the four CC-channels of\ntimer TIM1. Monitoring the repetion period might become a little complex, as\nit must be ensured that all servos on all channels have finshed before.",
            "title": "Servo library"
        },
        {
            "location": "/api/Servo/#servo-library",
            "text": "This library can control a great number of servos. It makes careful use\nof timers: the library can control 12 servos using only 1 timer.\nDerived from the Arduino Servo library v1.8.0.  This library has a slightly diffent user interface than the usual singleton\nlibraries. This allows for handling more than one servo per Sketch but it\nrequires some more attention when porting an existing sketch from C++ to C.  Each Servo instance is identified by a channel-ID. In order to match the C++\nclass constructor syntax it is defined as a type  Servo .  This channel-ID is used as a file-descriptor-like value and need to be\npassed to all API functions except for  Servo_attach() . This function\nclaimes the next free channel number.",
            "title": "Servo Library"
        },
        {
            "location": "/api/Servo/#example",
            "text": "Read a potentiometer on analog input 0 and set a servo pulse length between\n1000us and 2023us:  #include <Arduino.h>\n#include <Servo.h>\n\nServo myservo;          // just a simple unsigned char to hold the channel-ID\n\nint val;                // variable to read the value from the analog pin\n\nvoid setup() {\n  myservo = Servo_attach(9);    // attaches the servo on pin 9, returns channel-ID\n}\n\nvoid loop() {\n  val = analogRead(0);          // reads the value of the potentiometer\n  Servo_write(myservo, val+1000);// sets the servo position\n  delay(15);\n}  Original Arduino C++-Sytax:  #include <Servo.h>\n\nServo myservo;          // create servo object to control a servo\n\nint val;                // variable to read the value from the analog pin\n\nvoid setup() {\n  myservo.attach(9);    // attaches the servo on pin 9 to the servo object\n}\n\nvoid loop() {\n  val = analogRead(0);          // reads the value of the potentiometer\n  myservo.write(val+1000);      // sets the servo position\n  delay(15);\n}",
            "title": "Example"
        },
        {
            "location": "/api/Servo/#api",
            "text": "data type  Servo : A type definition for a simple unsigned char to hold the\nchannel number returned my  Servo_attach() . Needed for every servo. Syntax\nidentical to the Arduino class constructor.     Arduino syntax  sduino syntax      Servo myservo;  Servo myservo;    myservo.attach(pin);  myservo = Servo_attach(pin);    myservo.attach(pin,min,max);  Servo_attach_minmax(pin,min,max);    myservo.detach();  Servo_detach(byte channel);    myservo.write(val);  Servo_write(myservo, val);    myservo.writeMicroseconds(val);  Servo_writeMicroseconds(myservo, val);    val = myservo.read();  val = Servo_read(myservo);    val = myservo.readMicroseconds();  val = Servo_readMicroseconds(myservo);    myservo.attached()  Servo_attached(myservo);     uint8_t Servo_attach(int pin); \nattach the given pin to the next free channel, sets pinMode, returns channel\nnumber or 0 if failure.  uint8_t Servo_attach_minmax(int pin, int min, int max); \nas above but also sets min and max values for writes.   void Servo_detach(byte channel);  void Servo_write(byte channel, int value);  if value is < 200 it is treated\nas an angle and scaled according the minimum and maximum pulsewidth defined\nusing the attach() function earlier, otherwise as pulse width in\nmicroseconds, unscaled.  void Servo_writeMicroseconds(byte channel, int value); \nWrite pulse width in microseconds, unscaled.  int Servo_read(byte channel); \nreturns current pulse width as an angle between 0 and 180 degrees.  int Servo_readMicroseconds(byte channel); \nreturns current pulse width in microseconds for this servo (was read_us() in\nfirst Arduino release).  bool Servo_attached(byte channel); \nreturn true if this servo is attached, otherwise false .",
            "title": "API"
        },
        {
            "location": "/api/Servo/#relationship-between-pwmanalog-output-and-servo-output",
            "text": "It is not possible to use a timer for PWM and the Servo Library at the same\ntime. Since this library currently uses timer1, the PWM function\n( analogWrite() ) is disabled for the pins connected to timer1 (for the\nSTM8S103 this is pin PC3 and PC4 or digital pin 5 and 6).  Pins connected to timer2 (PA3, PD3, PD4, digital pin 2,12,13) are still\nusable for PWM output.",
            "title": "Relationship between PWM/analog output and Servo output"
        },
        {
            "location": "/api/Servo/#possible-improvements",
            "text": "A more sophisticated pseudo-OO API  Define a set of preprocessor macros that more OO-like definitions like this\nbecome possible:     Current syntax  OO-like syntax  Arduino syntax      myservo = Servo_attach(pin);  myservo_attach(pin);  myservo.attach(pin);    Servo_write(myservo, val);  myservo_write(val);  myservo_write(val);    val = Servo_read(myservo);  val = myservo_read();  val = myservo_read();     Optimizing the handle_interrupts() function  SDCC compiles this function very inefficiently. The code size is around 500\nBytes, and it is executed as part of the CC interrupt routine. Expected CPU\nload for a full servo group of 12 servos is approx. 2%.  (Calculated for 16MHz CPU clock, 13 interrupts every 20ms = 650\ninterrupts/sec, approx. 500 clock cycles each)  Using more than one CC channel per timer  it might be possible to use all capture+compare (CC) channels of one timer\nat the same time, attaching one servo group to each CC-channel. This way it\nwould be possible to serve up to 48 servos using the four CC-channels of\ntimer TIM1. Monitoring the repetion period might become a little complex, as\nit must be ensured that all servos on all channels have finshed before.",
            "title": "Possible improvements"
        },
        {
            "location": "/flashtool/",
            "text": "Flash tool\n\n\nYou need a special flash tools in order to program the CPU. As far as I know\nthere is no third-party product or software that implements the needed\ncommunication protocol. But this is not a problem, as these tools are are\neasily available and unbeliveably cheap (well under $3 on aliexpress).\n\n\nThere are to versions of the ST-Link V2 compatible flash tool available: One\nmade by Baite in a green plastic housing and one in a USB-Drive-like (often\npink) metal housing. Both work well, but they use a different pinout.\n\n\nBoth flash tools support the SWIM protocol for STM8 CPUs and the SWD\nprotocol for the STM32 CPUs. The programmer from Baite additionally supports\nJTAG and is superior to the more common one in the metal housing. More\ninformation on the hardware and the pinouts:\nhttps://wiki.cuvoodoo.info/doku.php?id=jtag\n\n\nPinout\n\n\nPinout of Chinese ST-Link V2-clone made by Baite with green plasic housing\n(supports SWIM, SWD and JTAG):\n\n\n            +-----+\n    T_JRST  | 1  2| 3V3\n    5V      | 3  4| T_JTCK/T_SWCLK\n    SWIM      5  6| T_JTMS/T_SWDIO\n    GND     | 7  8| T_JTDO\n    SWIM RST| 9 10| T_JTDI\n            +-----+\n\n\n\nPinout of Chinese ST-Link V2-clone with metal housing (supports SWIM and\nSWD):\n\n\n            +-----+\n    RST     | 1  2| SWDIO\n    GND     | 3  4| GND\n    SWIM      5  6| SWCLK\n    3V3     | 7  8| 3V3\n    5V      | 9 10| 5V\n            +-----+\n\n\n\nInstallation for Linux\n\n\nFor Linux: required lines in /etc/udev/rules.d/99-stlink.rules:\n\n\n# ST-Link/V2 programming adapter\n\n# ST-Link V1\n#SUBSYSTEM==\"usb\", ENV{DEVTYPE}==\"usb_device\",\nATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3744\", MODE=\"0666\", GROUP=\"plugdev\"\n\n# ST-Link/V2, the china adapter with the green plastic housing\n#SUBSYSTEM==\"usb\", ENV{DEVTYPE}==\"usb_device\", ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\"\nATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\", GROUP=\"plugdev\"\n\n\n\nConnection to the CPU board\n\n\nThe pinout of the SWIM connector P3 on my STM8S103 breakout board fits the\npinout of the flash tool in the metal housing perfectly:\n\n\n\n\n\n\n\n\nSignal\n\n\nSWIM connector P3\n\n\nBaite ST-Link\n\n\nMetal ST-Link\n\n\n\n\n\n\n\n\n\n\n3V3\n\n\n1\n\n\n2\n\n\n7\n\n\n\n\n\n\nSWIM\n\n\n2\n\n\n5\n\n\n5\n\n\n\n\n\n\nGND\n\n\n3\n\n\n7\n\n\n3\n\n\n\n\n\n\nNRST\n\n\n4\n\n\n9\n\n\n1\n\n\n\n\n\n\n\n\nThe Discovery boards made by ST all feature a ST-Link interface as well, but\nonly the Discovery STM8S105 supports the SWIM protocol. The Discovery\nSTM32F0308 implements SWD only and is not usable for the STM8:\n\n\n\n\n\n\n\n\nPin out CN3\n\n\nSWD\n\n\n\n\n\n\n\n\n\n\n1\n\n\n? detect oder so?\n\n\n\n\n\n\n2\n\n\nJTCK/SWCLK\n\n\n\n\n\n\n3\n\n\nGND\n\n\n\n\n\n\n4\n\n\nJTMS/SWDIO\n\n\n\n\n\n\n5\n\n\nNRST\n\n\n\n\n\n\n6\n\n\nSWO",
            "title": "Flash tool"
        },
        {
            "location": "/flashtool/#flash-tool",
            "text": "You need a special flash tools in order to program the CPU. As far as I know\nthere is no third-party product or software that implements the needed\ncommunication protocol. But this is not a problem, as these tools are are\neasily available and unbeliveably cheap (well under $3 on aliexpress).  There are to versions of the ST-Link V2 compatible flash tool available: One\nmade by Baite in a green plastic housing and one in a USB-Drive-like (often\npink) metal housing. Both work well, but they use a different pinout.  Both flash tools support the SWIM protocol for STM8 CPUs and the SWD\nprotocol for the STM32 CPUs. The programmer from Baite additionally supports\nJTAG and is superior to the more common one in the metal housing. More\ninformation on the hardware and the pinouts:\nhttps://wiki.cuvoodoo.info/doku.php?id=jtag",
            "title": "Flash tool"
        },
        {
            "location": "/flashtool/#pinout",
            "text": "Pinout of Chinese ST-Link V2-clone made by Baite with green plasic housing\n(supports SWIM, SWD and JTAG):              +-----+\n    T_JRST  | 1  2| 3V3\n    5V      | 3  4| T_JTCK/T_SWCLK\n    SWIM      5  6| T_JTMS/T_SWDIO\n    GND     | 7  8| T_JTDO\n    SWIM RST| 9 10| T_JTDI\n            +-----+  Pinout of Chinese ST-Link V2-clone with metal housing (supports SWIM and\nSWD):              +-----+\n    RST     | 1  2| SWDIO\n    GND     | 3  4| GND\n    SWIM      5  6| SWCLK\n    3V3     | 7  8| 3V3\n    5V      | 9 10| 5V\n            +-----+",
            "title": "Pinout"
        },
        {
            "location": "/flashtool/#installation-for-linux",
            "text": "For Linux: required lines in /etc/udev/rules.d/99-stlink.rules:  # ST-Link/V2 programming adapter\n\n# ST-Link V1\n#SUBSYSTEM==\"usb\", ENV{DEVTYPE}==\"usb_device\",\nATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3744\", MODE=\"0666\", GROUP=\"plugdev\"\n\n# ST-Link/V2, the china adapter with the green plastic housing\n#SUBSYSTEM==\"usb\", ENV{DEVTYPE}==\"usb_device\", ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\"\nATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\", GROUP=\"plugdev\"",
            "title": "Installation for Linux"
        },
        {
            "location": "/flashtool/#connection-to-the-cpu-board",
            "text": "The pinout of the SWIM connector P3 on my STM8S103 breakout board fits the\npinout of the flash tool in the metal housing perfectly:     Signal  SWIM connector P3  Baite ST-Link  Metal ST-Link      3V3  1  2  7    SWIM  2  5  5    GND  3  7  3    NRST  4  9  1     The Discovery boards made by ST all feature a ST-Link interface as well, but\nonly the Discovery STM8S105 supports the SWIM protocol. The Discovery\nSTM32F0308 implements SWD only and is not usable for the STM8:     Pin out CN3  SWD      1  ? detect oder so?    2  JTCK/SWCLK    3  GND    4  JTMS/SWDIO    5  NRST    6  SWO",
            "title": "Connection to the CPU board"
        },
        {
            "location": "/hardware/",
            "text": "Supported hardware\n\n\nNo text yet. Check out these pages:\n\n\n\n\nstm8blue: simple breakout board, STM8S103\n\n\nESP14: Wifi board, STM8S003\n\n\nSTM8S105Discovery: Evaluation board made my ST",
            "title": "List of supported boards"
        },
        {
            "location": "/hardware/#supported-hardware",
            "text": "No text yet. Check out these pages:   stm8blue: simple breakout board, STM8S103  ESP14: Wifi board, STM8S003  STM8S105Discovery: Evaluation board made my ST",
            "title": "Supported hardware"
        },
        {
            "location": "/pin_mapping/",
            "text": "Pin mapping scheme\n\n\nMany Arduino sketches and libraries contain hard-coded assumptions about the\nnumber of pins with special functions. Ideally, all these numbers would be\nthe same and all programs could be compiled without changes. This is not\npossible, but let's check how close we could get for the STM8S103F.\n\n\nPossible logical pin number mappings\n\n\nFunctional mapping\n would try to match the pins with special functions\n(like serial, SPI, I2C, analog input and PWM output) as closely as possible.\n\n\nGeometrical mapping\n would choose a logical order of the CPU pins as they\nare accessible on the CPU or with a breakout board.\n\n\nFunctional mapping would allow for designing a PCB using the Arduino Uno\nform factor and take advantage of all the existing shields (as long as they\nare 3.3V compatible). The number of needed changes to existing sketches\nwould be cut down to a minimum. The downside would be a pretty random order\nof pin numbers when using a simple breakout board.\n\n\nGeometrical mapping is easier for breadboard use, but will always require\nchanges on existing sketches. Since we need to modify them from C++ to C\nsyntax anyway that is maybe a less severe problem than it sounds.\n\n\na) Matching the communication pins\n\n\n\n\n\n\n\n\nSTM8 pin\n\n\nName\n\n\nAlt\n\n\nArduino pin\n\n\nATmega pin\n\n\nAlt\n\n\n\n\n\n\n\n\n\n\nPD6\n\n\nRX\n\n\nAin6\n\n\n0\n\n\nPD0\n\n\n\n\n\n\n\n\nPD5\n\n\nTX\n\n\nAin5\n\n\n1\n\n\nPD1\n\n\n\n\n\n\n\n\nPA3\n\n\nSS\n\n\n\n\n10\n\n\nPB2\n\n\nPWM\n\n\n\n\n\n\nPC6\n\n\nMOSI\n\n\n\n\n11\n\n\nPB3\n\n\nPWM\n\n\n\n\n\n\nPC7\n\n\nMISO\n\n\n\n\n12\n\n\nPB4\n\n\n\n\n\n\n\n\nPC5\n\n\nSCK\n\n\n\n\n13\n\n\nPB5\n\n\nLED\n\n\n\n\n\n\nPB5\n\n\nSDA\n\n\nLED\n\n\n18\n\n\nPC4\n\n\nAin4\n\n\n\n\n\n\nPB4\n\n\nSCL\n\n\n\n\n19\n\n\nPC5\n\n\nAin5\n\n\n\n\n\n\n\n\nb) Matching the analog inputs\n\n\n\n\n\n\n\n\nSTM8 pin\n\n\nName\n\n\nAlt\n\n\nArduino pin\n\n\nATmega pin\n\n\nAlt\n\n\n\n\n\n\n\n\n\n\nC4\n\n\nAin2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nD2\n\n\nAin3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nD3\n\n\nAin4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nD5\n\n\nAin5\n\n\nTX\n\n\n\n\n\n\n\n\n\n\n\n\nD6\n\n\nAin6\n\n\nRX\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nc) Matching the PWM-capable pins\n\n\n\n\n\n\n\n\nSTM8 pin\n\n\nName\n\n\nAlt\n\n\nArduino pin\n\n\nATmega pin\n\n\nAlt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9\n\n\n\n\n\n\n\n\n\n\n(\n\n\n\n\n\n\n10\n\n\n)\n\n\n\n\n\n\n\n\n(\n\n\n\n\n\n\n11\n\n\n)\n\n\n\n\n\n\n\n\n\n\nd) Matching the LED: (collision)\n\n\n\n\n\n\n\n\nSTM8 pin\n\n\nName\n\n\nAlt\n\n\nArduino pin\n\n\nATmega pin\n\n\nAlt\n\n\n\n\n\n\n\n\n\n\nPB5\n\n\nSDA\n\n\n\n\n13\n\n\nSCK\n\n\n\n\n\n\n\n\n\n\ne) Simple geometric numbering for SO20 package (count up from 1, starting at pin 1)\n\n\n 1-3  -> PD4-PD6\n 4-6  -> PA1-PA3\n 7-8  -> PB5-PB4 (reverse order)\n 9-13 -> PC3-PC7\n14-16 -> PD1-PD3\n\n\n\nSPI: 6,11,12,13 (same numbers as Arduino, but with different meanings ->\nerror prone)\n\nI2C: 7,8\n\nserial: 2,3\n\nAnalog: 2,3,10,15,16 (data sheet order would be: 10,15,16,2,3)  \n\n\n\n\nEasy and logical for use on a breadboard\n\n\nLogical port pin ordering\n\n\nAnalog pins are scattered\n\n\nAll functions use totally different pin numbers than Arduino\n\n\n\n\nf) Simple geometric numbering for square UFQFPN20 package (count up from 0, starting at pin 2/PA1)\n\n\n 0-2  -> PA1-PA3\n 3-4  -> PB5-PB4 (reverse order)\n 5-9 -> PC3-PC7\n10-15 -> PD1-PD6\n\n\n\nserial: 14,15\n\nSPI: 2,7,8,9\n\nI2C: 3,4\n\nAnalog: 6,11,12,14,15 (for an easier structure maybe use non-continous\nnumbers for the Arduino-like Ax-numbers: A0, A1, A2, A4, A5)\n\nPWM: 2,5,6,12 plus either only 13 or 7-9 but not 13 (via alternate mapping)\n\nPWM Bitmap pin 15-0: 0011 0000 0110 0100 = 0x3064 (regular mapping)\n\nPWM Bitmap pin 15-0: 0001 0011 1110 0100 = 0x13e4 (alternate mapping)  \n\n\n\n\nEasy and logical for use on a breadboard\n\n\nVery clear and logical port pin ordering\n\n\nAnalog pins are still scattered around\n\n\nTX and RX would be the rarely used analog pin numbers A3/A4 or A4/A5 at\n   the end of the analog pin number list\n\n\nAt least the analog pins are in data sheet order\n\n\nAll functions use totally different pin numbers than Arduino\n\n\n\n\nComparing the results\n\n\nCompare logical/functional mapping vs. simple geometrical numbering\n\n\n\n\n\n\n\n\nPhys. STM8 pin\n\n\nName\n\n\nFunctions\n\n\nFunctional mapping\n\n\nGeometrical\n\n\nmapping\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstrict\n\n\nfrom PA1\n\n\n\n\n\n\n1\n\n\nPD4\n\n\nUART_CLK/T2-1/beep\n\n\n5\n\n\n1~\n\n\n13~\n\n\n\n\n\n\n2\n\n\nPD5\n\n\nTX/Ain5\n\n\n\n\n1\n\n\n2  14/A3\n\n\n\n\n\n\n3\n\n\nPD6\n\n\nRX/Ain6\n\n\n\n\n0\n\n\n3  15/A4\n\n\n\n\n\n\n5\n\n\nPA1\n\n\n(OscIn, kein HS)\n\n\n6\n\n\n4\n\n\n0\n\n\n\n\n\n\n6\n\n\nPA2\n\n\n(OscIn, kein HS)\n\n\n7\n\n\n5\n\n\n1\n\n\n\n\n\n\n10\n\n\nPA3\n\n\nSS/T2-3\n\n\n\n\n10\n\n\n6~ 2~\n\n\n\n\n\n\n11\n\n\nPB5\n\n\nSDA    LED\n\n\n18\n\n\n7\n\n\n3\n\n\n\n\n\n\n12\n\n\nPB4\n\n\nSCL\n\n\n19\n\n\n8\n\n\n4\n\n\n\n\n\n\n13\n\n\nPC3\n\n\nT1-3/[T1-n1]\n\n\n9\n\n\n9~\n\n\n5~(n~)\n\n\n\n\n\n\n14\n\n\nPC4\n\n\nT1-4/Ain2/[T1-n2]\n\n\n4\n\n\n10~\n\n\n6~(n~)/A0\n\n\n\n\n\n\n15\n\n\nPC5\n\n\nSCK/[T2-1]\n\n\n13\n\n\n11~\n\n\n7(~)\n\n\n\n\n\n\n16\n\n\nPC6\n\n\nMOSI/[T1-1]\n\n\n11\n\n\n12~\n\n\n8(~)\n\n\n\n\n\n\n17\n\n\nPC7\n\n\nMISO/[T1-2]\n\n\n12\n\n\n13~\n\n\n9(~)\n\n\n\n\n\n\n18\n\n\nPD1\n\n\n(SWIM)\n\n\n8\n\n\n14\n\n\n10\n\n\n\n\n\n\n19\n\n\nPD2\n\n\nAin3/[T2-3]\n\n\n3\n\n\n15(~)\n\n\n11(~~)/A1\n\n\n\n\n\n\n20\n\n\nPD3\n\n\nAin4/T2-2\n\n\n2\n\n\n16~\n\n\n12~/A2\n\n\n\n\n\n\n\n\nFunctional pin mapping:\n\n\nTX/RX,SPI,I2C match the Arduino numbers\n\n\nAnalog mapped to D0-D4 (instead of D14-D19),\n\n\nPWM 2,3,4,5,9,10,11,12,13 (Arduino PWM: 3,5,6,9,10,11, all matched except\nfor pin 6)\n\n\nnon-existant: 14-17 -> it might be better to map I2C to 14 and 15.\n\n\nStrict geometrical pin mapping:\n\n\nSPI: 6,11,12,13 (same numbers as Arduino, but with different meanings ->\nerror prone)\n\nI2C: 7,8\n\nserial: 2,3\n\nanalog: 2,3,10,15,16\n\nPWM regular: 2,12,13\n\nPWM alternate: 7,8,9\n\nPWM alternate negative: 5,6\n\nPWM alternate (duplicates): 11  \n\n\nPin remapping\n\n\nSome functions share the same CPU port pin. The Alternate function remapping\nregister (AFR) is used to choose the actual function. Most important choice\nis for pin PC5-PC7: SPI (default) or PWM (alternate). Unfortunatly, this\ninfluences PD4 as well (default PWM, alternate non-PWM).\n\n\nThe AFR is two EEPROM cells at 0x4803 (OPT2) and 0x4804 (NOPT2, inverted).\nProgrammable via SWIM (see UM0470) and in IAP-Mode (see PM0051).\n\n\n\n\n\n\n\n\nBit\n\n\nPin influenced\n\n\nFunction for 0\n\n\nFunction for 1\n\n\n\n\n\n\n\n\n\n\nAFR7\n\n\nPC3,PC4\n\n\ndefault\n\n\nTIM1_CH1N, TIM1_CH2N\n\n\n\n\n\n\nAFR4\n\n\nPB4,PB5\n\n\ndefault\n\n\nADC_ETR, TIM1_BKIN\n\n\n\n\n\n\nAFR3\n\n\nPC3\n\n\ndefault\n\n\nTLI\n\n\n\n\n\n\nAFR1\n\n\nPA3,PD2\n\n\ndefault\n\n\nSPI_NSS, TIM2_CH3\n\n\n\n\n\n\nAFR0\n\n\nPC5-PC7\n\n\nGPIO/SPI\n\n\nTIM2_CH1, TIM1_CH1, TIM1_CH2",
            "title": "Ways to define a pin mapping"
        },
        {
            "location": "/pin_mapping/#pin-mapping-scheme",
            "text": "Many Arduino sketches and libraries contain hard-coded assumptions about the\nnumber of pins with special functions. Ideally, all these numbers would be\nthe same and all programs could be compiled without changes. This is not\npossible, but let's check how close we could get for the STM8S103F.",
            "title": "Pin mapping scheme"
        },
        {
            "location": "/pin_mapping/#possible-logical-pin-number-mappings",
            "text": "Functional mapping  would try to match the pins with special functions\n(like serial, SPI, I2C, analog input and PWM output) as closely as possible.  Geometrical mapping  would choose a logical order of the CPU pins as they\nare accessible on the CPU or with a breakout board.  Functional mapping would allow for designing a PCB using the Arduino Uno\nform factor and take advantage of all the existing shields (as long as they\nare 3.3V compatible). The number of needed changes to existing sketches\nwould be cut down to a minimum. The downside would be a pretty random order\nof pin numbers when using a simple breakout board.  Geometrical mapping is easier for breadboard use, but will always require\nchanges on existing sketches. Since we need to modify them from C++ to C\nsyntax anyway that is maybe a less severe problem than it sounds.  a) Matching the communication pins     STM8 pin  Name  Alt  Arduino pin  ATmega pin  Alt      PD6  RX  Ain6  0  PD0     PD5  TX  Ain5  1  PD1     PA3  SS   10  PB2  PWM    PC6  MOSI   11  PB3  PWM    PC7  MISO   12  PB4     PC5  SCK   13  PB5  LED    PB5  SDA  LED  18  PC4  Ain4    PB4  SCL   19  PC5  Ain5     b) Matching the analog inputs     STM8 pin  Name  Alt  Arduino pin  ATmega pin  Alt      C4  Ain2        D2  Ain3        D3  Ain4        D5  Ain5  TX       D6  Ain6  RX        c) Matching the PWM-capable pins     STM8 pin  Name  Alt  Arduino pin  ATmega pin  Alt         3         5         6         9      (    10  )     (    11  )      d) Matching the LED: (collision)     STM8 pin  Name  Alt  Arduino pin  ATmega pin  Alt      PB5  SDA   13  SCK      e) Simple geometric numbering for SO20 package (count up from 1, starting at pin 1)   1-3  -> PD4-PD6\n 4-6  -> PA1-PA3\n 7-8  -> PB5-PB4 (reverse order)\n 9-13 -> PC3-PC7\n14-16 -> PD1-PD3  SPI: 6,11,12,13 (same numbers as Arduino, but with different meanings ->\nerror prone) \nI2C: 7,8 \nserial: 2,3 \nAnalog: 2,3,10,15,16 (data sheet order would be: 10,15,16,2,3)     Easy and logical for use on a breadboard  Logical port pin ordering  Analog pins are scattered  All functions use totally different pin numbers than Arduino   f) Simple geometric numbering for square UFQFPN20 package (count up from 0, starting at pin 2/PA1)   0-2  -> PA1-PA3\n 3-4  -> PB5-PB4 (reverse order)\n 5-9 -> PC3-PC7\n10-15 -> PD1-PD6  serial: 14,15 \nSPI: 2,7,8,9 \nI2C: 3,4 \nAnalog: 6,11,12,14,15 (for an easier structure maybe use non-continous\nnumbers for the Arduino-like Ax-numbers: A0, A1, A2, A4, A5) \nPWM: 2,5,6,12 plus either only 13 or 7-9 but not 13 (via alternate mapping) \nPWM Bitmap pin 15-0: 0011 0000 0110 0100 = 0x3064 (regular mapping) \nPWM Bitmap pin 15-0: 0001 0011 1110 0100 = 0x13e4 (alternate mapping)     Easy and logical for use on a breadboard  Very clear and logical port pin ordering  Analog pins are still scattered around  TX and RX would be the rarely used analog pin numbers A3/A4 or A4/A5 at\n   the end of the analog pin number list  At least the analog pins are in data sheet order  All functions use totally different pin numbers than Arduino",
            "title": "Possible logical pin number mappings"
        },
        {
            "location": "/pin_mapping/#comparing-the-results",
            "text": "Compare logical/functional mapping vs. simple geometrical numbering     Phys. STM8 pin  Name  Functions  Functional mapping  Geometrical  mapping          strict  from PA1    1  PD4  UART_CLK/T2-1/beep  5  1~  13~    2  PD5  TX/Ain5   1  2  14/A3    3  PD6  RX/Ain6   0  3  15/A4    5  PA1  (OscIn, kein HS)  6  4  0    6  PA2  (OscIn, kein HS)  7  5  1    10  PA3  SS/T2-3   10  6~ 2~    11  PB5  SDA    LED  18  7  3    12  PB4  SCL  19  8  4    13  PC3  T1-3/[T1-n1]  9  9~  5~(n~)    14  PC4  T1-4/Ain2/[T1-n2]  4  10~  6~(n~)/A0    15  PC5  SCK/[T2-1]  13  11~  7(~)    16  PC6  MOSI/[T1-1]  11  12~  8(~)    17  PC7  MISO/[T1-2]  12  13~  9(~)    18  PD1  (SWIM)  8  14  10    19  PD2  Ain3/[T2-3]  3  15(~)  11(~~)/A1    20  PD3  Ain4/T2-2  2  16~  12~/A2     Functional pin mapping:  TX/RX,SPI,I2C match the Arduino numbers  Analog mapped to D0-D4 (instead of D14-D19),  PWM 2,3,4,5,9,10,11,12,13 (Arduino PWM: 3,5,6,9,10,11, all matched except\nfor pin 6)  non-existant: 14-17 -> it might be better to map I2C to 14 and 15.  Strict geometrical pin mapping:  SPI: 6,11,12,13 (same numbers as Arduino, but with different meanings ->\nerror prone) \nI2C: 7,8 \nserial: 2,3 \nanalog: 2,3,10,15,16 \nPWM regular: 2,12,13 \nPWM alternate: 7,8,9 \nPWM alternate negative: 5,6 \nPWM alternate (duplicates): 11",
            "title": "Comparing the results"
        },
        {
            "location": "/pin_mapping/#pin-remapping",
            "text": "Some functions share the same CPU port pin. The Alternate function remapping\nregister (AFR) is used to choose the actual function. Most important choice\nis for pin PC5-PC7: SPI (default) or PWM (alternate). Unfortunatly, this\ninfluences PD4 as well (default PWM, alternate non-PWM).  The AFR is two EEPROM cells at 0x4803 (OPT2) and 0x4804 (NOPT2, inverted).\nProgrammable via SWIM (see UM0470) and in IAP-Mode (see PM0051).     Bit  Pin influenced  Function for 0  Function for 1      AFR7  PC3,PC4  default  TIM1_CH1N, TIM1_CH2N    AFR4  PB4,PB5  default  ADC_ETR, TIM1_BKIN    AFR3  PC3  default  TLI    AFR1  PA3,PD2  default  SPI_NSS, TIM2_CH3    AFR0  PC5-PC7  GPIO/SPI  TIM2_CH1, TIM1_CH1, TIM1_CH2",
            "title": "Pin remapping"
        },
        {
            "location": "/hardware/stm8blue/",
            "text": "Generic STM8S103 breakout board\n\n\nThese simple breakout boards are available on aliexpress for well under one\nDollar (I got mine for 67 cent each, including shipping from China). They\nare my original development platform.\n\n\n\n\nThey are very similar the \nESP14 Wifi-boards\n, most\nprograms should run on those chinese gems as well, but that is still\nuntested.\n\n\nThe STM8S103 breakout boards are build around a CPU STM8S103F3P6 with 16MHz\ninternal oscillator, 8kB flash, 1kB RAM, and 640 byte EEPROM. The CPU\nincludes a UART, SPI, I2C, PWM, 10 bit ADC, 3 timer, and up to 14 I/O pins -\nquite similar to an Atmel ATmega8.\n\n\nOne (red) LED is connected to GPIO PB5 (CPU pin 11). The push button is for\nreset. The CPU runs on 3.3V, a linear regulator is integrated on the\nboard. The micro USB connector is only for (5V) power supply, the data lines\nare not connected.\n\n\nAll CPU pins are easily accessible on (optional) pin headers (pitch 2.54mm,\nperfect for breadboards).\n\n\n\n\nMy breakout boards came preprogrammed with a blink program and with active\nwrite protection bits. For unlocking before first use:\n\n\nstm8flash -cstlinkv2 -pstm8s103?3 -u\n\n\n\nConnection to the flash tool\n\n\nI am using the ST-Link V2 compatible flash tool in the green plastic\nhousing. The one in the metal housing uses a different pinout.\n\n\nConnection to the flashtool:\n\n\n\n\n\n\n\n\nSignal name\n\n\nP3 on CPU board\n\n\nGreen flash tool\n\n\nMetal flash tool\n\n\n\n\n\n\n\n\n\n\n3V3\n\n\n1\n\n\n2\n\n\n7\n\n\n\n\n\n\nSWIM\n\n\n2\n\n\n5\n\n\n5\n\n\n\n\n\n\nGND\n\n\n3\n\n\n7\n\n\n3\n\n\n\n\n\n\nNRST\n\n\n4\n\n\n9\n\n\n1\n\n\n\n\n\n\n\n\nPin number mappings\n\n\nThe Arduino environment uses its own pin numbering scheme independent from\nthe physical CPU pin numbers. Many Arduino sketches and libraries contain\nhard-coded assumptions about the number of pins with special functions.\nIdeally, all these numbers would be the same and all programs could be\ncompiled without changes.\n\n\nHere\n I discuss some possible pin mapping and check\nhow close we could get the the ideal mapping. Unfortunatly, it turns out\nthat a perfect mapping is not possible.\n\n\nIn the end I chose a simple geometric numbering for the square UFQFPN20\npackage starting with port pin PA1 and counting up from 0. This results in\nthis mapping:\n\n\n\n\nThe pins D3/D4 (SDA/SCL, PB5/PB4) are different from the others as they are\ntrue open drain pins. That means, they only can drive the output low or\nopen. To drive it high, they require the of an external pull-up resistor.\nThis is the reason why the LED on this breakout is connected between +3.3V\nand the pins and not between the pin GND as usual. This way it is possible\nto drive the LED by writing a zero to the output register.\n\n\n\n\n\n\n\n\nsduino pin\n\n\nSTM8S103 CPU port pin\n\n\n\n\n\n\n\n\n\n\n0-2\n\n\nPA1-PA3 (PA1 and PA2 only weak output drivers)\n\n\n\n\n\n\n3-4\n\n\nPB5-PB4 (reverse order)\n\n\n\n\n\n\n5-9\n\n\nPC3-PC7\n\n\n\n\n\n\n10-15\n\n\nPD1-PD6\n\n\n\n\n\n\n\n\nserial: 14,15\n\nSPI: 2,7,8,9\n\nI2C: 3,4 (true open drain. can't drive a high signal without an external\npull-up resistor)\nAnalog: 6,11,12,14,15\n\nPWM: 2,5,6,12 plus either only 13 or 7-9 but not 13 (via alternate mapping)  \n\n\n\n\nEasy and logical for use on a breadboard\n\n\nVery clear and logical port pin ordering\n\n\nAnalog pins are still scattered around\n\n\nTX and RX would be the rarely used analog pin numbers A3/A4 at\n   the end of the analog pin number list\n\n\nAt least the analog pins are in data sheet order\n\n\nAll functions use totally different pin numbers than Arduino\n\n\n\n\nI am still not really happy with this mapping. Instead of simplifing things\nit only adds another layer of abstraction and confusion. To avoid this I\nadded definitions for the regular CPU pin names like \nPA1\n and \nPD2\n. In the\nend, this notation seems to be a lot easier to me. I am open for suggestions\nfor a better pin number mapping.\n\n\nThe chosen pin mapping for the STM8S103 (possible alternate function in\nparatheses):\n\n\n\n\n\n\n\n\nPhys. STM8 pin\n\n\nName\n\n\nFunctions\n\n\nGeometrical mapping\n\n\nspecial funcion\n\n\n\n\n\n\n\n\n\n\n1\n\n\nPD4\n\n\nUART_CLK/T2-1/beep\n\n\n13\n\n\nPWM\n\n\n\n\n\n\n2\n\n\nPD5\n\n\nTX/Ain5\n\n\n14\n\n\nAnalog A3\n\n\n\n\n\n\n3\n\n\nPD6\n\n\nRX/Ain6\n\n\n15\n\n\nAnalog A4\n\n\n\n\n\n\n5\n\n\nPA1\n\n\n(OscIn, kein HS)\n\n\n0\n\n\n\n\n\n\n\n\n6\n\n\nPA2\n\n\n(OscIn, kein HS)\n\n\n1\n\n\n\n\n\n\n\n\n10\n\n\nPA3\n\n\nSS/T2-3\n\n\n2\n\n\nPWM\n\n\n\n\n\n\n11\n\n\nPB5\n\n\nSDA    LED\n\n\n3\n\n\n\n\n\n\n\n\n12\n\n\nPB4\n\n\nSCL\n\n\n4\n\n\n\n\n\n\n\n\n13\n\n\nPC3\n\n\nT1-3/[T1-n1]\n\n\n5\n\n\nPWM, (n~)\n\n\n\n\n\n\n14\n\n\nPC4\n\n\nT1-4/Ain2/[T1-n2]\n\n\n6\n\n\nPWM, Analog A0, (n~)\n\n\n\n\n\n\n15\n\n\nPC5\n\n\nSCK/[T2-1]\n\n\n7\n\n\n(~)\n\n\n\n\n\n\n16\n\n\nPC6\n\n\nMOSI/[T1-1]\n\n\n8\n\n\n(~)\n\n\n\n\n\n\n17\n\n\nPC7\n\n\nMISO/[T1-2]\n\n\n9\n\n\n(~)\n\n\n\n\n\n\n18\n\n\nPD1\n\n\n(SWIM)\n\n\n10\n\n\n\n\n\n\n\n\n19\n\n\nPD2\n\n\nAin3/[T2-3]\n\n\n11\n\n\nAnalog A1, (~~)\n\n\n\n\n\n\n20\n\n\nPD3\n\n\nAin4/T2-2\n\n\n12\n\n\nPWM, Analog A2",
            "title": "Generic STM8S103 breakout board (stm8blue)"
        },
        {
            "location": "/hardware/stm8blue/#generic-stm8s103-breakout-board",
            "text": "These simple breakout boards are available on aliexpress for well under one\nDollar (I got mine for 67 cent each, including shipping from China). They\nare my original development platform.   They are very similar the  ESP14 Wifi-boards , most\nprograms should run on those chinese gems as well, but that is still\nuntested.  The STM8S103 breakout boards are build around a CPU STM8S103F3P6 with 16MHz\ninternal oscillator, 8kB flash, 1kB RAM, and 640 byte EEPROM. The CPU\nincludes a UART, SPI, I2C, PWM, 10 bit ADC, 3 timer, and up to 14 I/O pins -\nquite similar to an Atmel ATmega8.  One (red) LED is connected to GPIO PB5 (CPU pin 11). The push button is for\nreset. The CPU runs on 3.3V, a linear regulator is integrated on the\nboard. The micro USB connector is only for (5V) power supply, the data lines\nare not connected.  All CPU pins are easily accessible on (optional) pin headers (pitch 2.54mm,\nperfect for breadboards).   My breakout boards came preprogrammed with a blink program and with active\nwrite protection bits. For unlocking before first use:  stm8flash -cstlinkv2 -pstm8s103?3 -u",
            "title": "Generic STM8S103 breakout board"
        },
        {
            "location": "/hardware/stm8blue/#connection-to-the-flash-tool",
            "text": "I am using the ST-Link V2 compatible flash tool in the green plastic\nhousing. The one in the metal housing uses a different pinout.  Connection to the flashtool:     Signal name  P3 on CPU board  Green flash tool  Metal flash tool      3V3  1  2  7    SWIM  2  5  5    GND  3  7  3    NRST  4  9  1",
            "title": "Connection to the flash tool"
        },
        {
            "location": "/hardware/stm8blue/#pin-number-mappings",
            "text": "The Arduino environment uses its own pin numbering scheme independent from\nthe physical CPU pin numbers. Many Arduino sketches and libraries contain\nhard-coded assumptions about the number of pins with special functions.\nIdeally, all these numbers would be the same and all programs could be\ncompiled without changes.  Here  I discuss some possible pin mapping and check\nhow close we could get the the ideal mapping. Unfortunatly, it turns out\nthat a perfect mapping is not possible.  In the end I chose a simple geometric numbering for the square UFQFPN20\npackage starting with port pin PA1 and counting up from 0. This results in\nthis mapping:   The pins D3/D4 (SDA/SCL, PB5/PB4) are different from the others as they are\ntrue open drain pins. That means, they only can drive the output low or\nopen. To drive it high, they require the of an external pull-up resistor.\nThis is the reason why the LED on this breakout is connected between +3.3V\nand the pins and not between the pin GND as usual. This way it is possible\nto drive the LED by writing a zero to the output register.     sduino pin  STM8S103 CPU port pin      0-2  PA1-PA3 (PA1 and PA2 only weak output drivers)    3-4  PB5-PB4 (reverse order)    5-9  PC3-PC7    10-15  PD1-PD6     serial: 14,15 \nSPI: 2,7,8,9 \nI2C: 3,4 (true open drain. can't drive a high signal without an external\npull-up resistor)\nAnalog: 6,11,12,14,15 \nPWM: 2,5,6,12 plus either only 13 or 7-9 but not 13 (via alternate mapping)     Easy and logical for use on a breadboard  Very clear and logical port pin ordering  Analog pins are still scattered around  TX and RX would be the rarely used analog pin numbers A3/A4 at\n   the end of the analog pin number list  At least the analog pins are in data sheet order  All functions use totally different pin numbers than Arduino   I am still not really happy with this mapping. Instead of simplifing things\nit only adds another layer of abstraction and confusion. To avoid this I\nadded definitions for the regular CPU pin names like  PA1  and  PD2 . In the\nend, this notation seems to be a lot easier to me. I am open for suggestions\nfor a better pin number mapping.  The chosen pin mapping for the STM8S103 (possible alternate function in\nparatheses):     Phys. STM8 pin  Name  Functions  Geometrical mapping  special funcion      1  PD4  UART_CLK/T2-1/beep  13  PWM    2  PD5  TX/Ain5  14  Analog A3    3  PD6  RX/Ain6  15  Analog A4    5  PA1  (OscIn, kein HS)  0     6  PA2  (OscIn, kein HS)  1     10  PA3  SS/T2-3  2  PWM    11  PB5  SDA    LED  3     12  PB4  SCL  4     13  PC3  T1-3/[T1-n1]  5  PWM, (n~)    14  PC4  T1-4/Ain2/[T1-n2]  6  PWM, Analog A0, (n~)    15  PC5  SCK/[T2-1]  7  (~)    16  PC6  MOSI/[T1-1]  8  (~)    17  PC7  MISO/[T1-2]  9  (~)    18  PD1  (SWIM)  10     19  PD2  Ain3/[T2-3]  11  Analog A1, (~~)    20  PD3  Ain4/T2-2  12  PWM, Analog A2",
            "title": "Pin number mappings"
        },
        {
            "location": "/hardware/esp14/",
            "text": "ESP-14\n\n\nAn ESP-8266 Wifi-Controller together with a STM8S003 CPU for about $2 -\nincredible.  Since the STM8S003 is almost identical to the STM8S103 used on\nthe \nSTM8S103 breakout boards\n all software runs here as well.\n\n\nUsing the same pin numbering scheme as with the stm8blue boards it looks\nlike this:\n\n\n\n\nDifferences between the '003 and the '103 CPUs\n\n\nVery slim. All differences that I could find so far:\n\n\n\n\n\n\n\n\nFeature\n\n\nSTM8S003\n\n\nSTM8S103\n\n\n\n\n\n\n\n\n\n\nEEPROM size\n\n\n128 Bytes\n\n\n640 Bytes\n\n\n\n\n\n\n\n\nI am not sure why the '003 is sold for half the price, or, to but it the\nother way around, why anybody should choose the '103 at all. Did I miss an\nimportant difference?\n\n\nUsing the Wifi connection\n\n\nThe ESP-14 is basically an ESP-01 Wifi-module together with a STM8S breakout\nboard combined into one PCB. The ESP part comes preprogrammed with the\nusual ESP AT-Firmware and is connected to the RX/TX pins of the STM8S.\n\n\nIt feels like having a classic ATmega8-Arduino with a build-in ESP-01\nmodule. Using the \nWiFiEsp library\n\nwe could have a programming experience very similar to using an Arduino with\na Wifi-shield.\n\n\nProblem is the limited flash space of the '003. Even the very basic\nWebServer example that comes with the WiFiEsp library needs more then 14kB\nflash and more than 1kB RAM when compiled for an Arduino Uno. Even if the\nlibrary could be carefully optimized to fit into the 8kB flash of an '003 -\nthere would be no space left for the actual user code.\n\n\nIt is still possible to do very simple task by just sending AT-strings to\nthe ESP. But here we are definitly leaving Ardunio territory. Here we have\nto start from scratch and do it all by ourself. This is not going to be\nbeginner-friendly anymore.\n\n\nThe major remaining advantage of the STM8S over the ESP is power efficiency.\nThe STM8S runs on almost nothing, while the ESP draws anything between 50\nand 200mA even for the simplest tasks.\n\n\nIn most cases you might want to implement the external communication part of\nthe application on the ESP, using the\n\nESP8266 Arduino port\n.\n\n\nThe STM8S is better suited to local control and measurement and other\nenergy- and time-critical tasks. Both CPUs use separate power supply inputs.\nUsing an additional PMOS transistor the STM8S could control the power supply\nfor the ESP and help extending battery life by activating the big brother\nonly when its services are actually required.\n\n\nPoor design choice\n\n\nOverall, the '003 is a very questionable CPU choice by AI Thinker. The '003\nis clearly one of the cheapest CPUs on the market, but the applications for\nthis module are heavily restricted the the small flash memory.\n\n\nWhy didn't they use an ATmega328? Just one dollar more and the whole Arduino\nuniverse opens up. Or at least an STM8S005K6T6C, offering 32kB flash and 2kB\nRAM for only 40 cents more, if you want to go really cheap.\n\n\nAnd why would you need an external PMOS to control the ESP power supply?\nWhy is this not included on the PCB already? This could the big killer\nfeature of the current combination.\n\n\nThe upside\n\n\nHaving a beefy 32 bit CPU and using it as an I/O-coprocessor while running\nthe main application on an resticted 8-bitter is a weired concept. Things\nlike the Arduino Yun or the Arduino WiFi-shield don't make too much sense.\n\n\nIt is much more sensible to use the big CPU to control the small one than\nthe other way around. Maybe this board can help to promote that concept.",
            "title": "ESP14: Wifi board, STM8S003"
        },
        {
            "location": "/hardware/esp14/#esp-14",
            "text": "An ESP-8266 Wifi-Controller together with a STM8S003 CPU for about $2 -\nincredible.  Since the STM8S003 is almost identical to the STM8S103 used on\nthe  STM8S103 breakout boards  all software runs here as well.  Using the same pin numbering scheme as with the stm8blue boards it looks\nlike this:",
            "title": "ESP-14"
        },
        {
            "location": "/hardware/esp14/#differences-between-the-003-and-the-103-cpus",
            "text": "Very slim. All differences that I could find so far:     Feature  STM8S003  STM8S103      EEPROM size  128 Bytes  640 Bytes     I am not sure why the '003 is sold for half the price, or, to but it the\nother way around, why anybody should choose the '103 at all. Did I miss an\nimportant difference?",
            "title": "Differences between the '003 and the '103 CPUs"
        },
        {
            "location": "/hardware/esp14/#using-the-wifi-connection",
            "text": "The ESP-14 is basically an ESP-01 Wifi-module together with a STM8S breakout\nboard combined into one PCB. The ESP part comes preprogrammed with the\nusual ESP AT-Firmware and is connected to the RX/TX pins of the STM8S.  It feels like having a classic ATmega8-Arduino with a build-in ESP-01\nmodule. Using the  WiFiEsp library \nwe could have a programming experience very similar to using an Arduino with\na Wifi-shield.  Problem is the limited flash space of the '003. Even the very basic\nWebServer example that comes with the WiFiEsp library needs more then 14kB\nflash and more than 1kB RAM when compiled for an Arduino Uno. Even if the\nlibrary could be carefully optimized to fit into the 8kB flash of an '003 -\nthere would be no space left for the actual user code.  It is still possible to do very simple task by just sending AT-strings to\nthe ESP. But here we are definitly leaving Ardunio territory. Here we have\nto start from scratch and do it all by ourself. This is not going to be\nbeginner-friendly anymore.  The major remaining advantage of the STM8S over the ESP is power efficiency.\nThe STM8S runs on almost nothing, while the ESP draws anything between 50\nand 200mA even for the simplest tasks.  In most cases you might want to implement the external communication part of\nthe application on the ESP, using the ESP8266 Arduino port .  The STM8S is better suited to local control and measurement and other\nenergy- and time-critical tasks. Both CPUs use separate power supply inputs.\nUsing an additional PMOS transistor the STM8S could control the power supply\nfor the ESP and help extending battery life by activating the big brother\nonly when its services are actually required.",
            "title": "Using the Wifi connection"
        },
        {
            "location": "/hardware/esp14/#poor-design-choice",
            "text": "Overall, the '003 is a very questionable CPU choice by AI Thinker. The '003\nis clearly one of the cheapest CPUs on the market, but the applications for\nthis module are heavily restricted the the small flash memory.  Why didn't they use an ATmega328? Just one dollar more and the whole Arduino\nuniverse opens up. Or at least an STM8S005K6T6C, offering 32kB flash and 2kB\nRAM for only 40 cents more, if you want to go really cheap.  And why would you need an external PMOS to control the ESP power supply?\nWhy is this not included on the PCB already? This could the big killer\nfeature of the current combination.",
            "title": "Poor design choice"
        },
        {
            "location": "/hardware/esp14/#the-upside",
            "text": "Having a beefy 32 bit CPU and using it as an I/O-coprocessor while running\nthe main application on an resticted 8-bitter is a weired concept. Things\nlike the Arduino Yun or the Arduino WiFi-shield don't make too much sense.  It is much more sensible to use the big CPU to control the small one than\nthe other way around. Maybe this board can help to promote that concept.",
            "title": "The upside"
        },
        {
            "location": "/hardware/stm8sdiscovery/",
            "text": "STM8S Discovery\n\n\nA widespread evaluation board made by ST. All CPU pin are easily accessible\non 2x6 pin headers. It costs only $9 and includes a ST-Link/v1 flash\nprogrammer on board.\n\n\nIt should work now, but the support is very fresh and not thoroughly tested. \nAt least Blink.c is known to work already.\n\n\nSTM8S105C6T6 microcontroller, 32 KB Flash, 2 KB RAM, 1 KB EEPROM \n\n\n\n\nLED on PD0, active low.\n\n\nTouch button on PC1, PC2, PC3\n\n\nexternal crystal 16MHz on PA1/PA2\n\n\n\n\nThe touch pins PC1 and PC3 (Arduino-Pin 24 and 26) are not connected to the\npin header on the board. To use them as I/O-pins you need to modify some\nsolder bridges (See STM8S-Discovery user manual).\n\n\nSWIM connector\n\n\nPinout of CN7 SWIM connector\n\n\n\n\n\n\n\n\nPin\n\n\nSignal\n\n\n\n\n\n\n\n\n\n\n1\n\n\nVdd (3.3V)\n\n\n\n\n\n\n2\n\n\nSWIM\n\n\n\n\n\n\n3\n\n\nGND\n\n\n\n\n\n\n4\n\n\nNRST\n\n\n\n\n\n\n\n\nUsage with Linux and stm8flash\n\n\nThe discovery board implements two USB devices: A ST-LINK/V1 interface and a\n(not very useful) mass storage device with some links to the ST website. The\nimplementation of this mass storage device is very buggy and renders the\nhole board useless. You need to make modprobe to ignore it by adding this\nline to /etc/modprobe.conf or by adding a file\n/etc/modprobe.d/stdiscovery.conf with this line:\n\n\noptions usb-storage quirks=0483:3744:i\n\n\n\nUnplug the Discovery board and unload the usb mass storage driver with\n\n\nmodprobe -r uas usb_storage\n\n\n\nIf you can't unload the usb_storage drive because it is in use with other\ndevices you can temporary trigger the same effect by this line:\n\n\necho \"0483:3744:i\" >/sys/module/usb_storage/parameters/quirks\n\n\n\nThe second step is to add a new udev rule in order to access the USB port.\nSave this as root in in \n/etc/udev/rules.d/99-stlink.rules\n:\n\n\n# ST-Link/V2 programming adapter\n\n# ST-Link V1, if using a STM8S discovery board\n# important: It needs a special entry in /etc/modprob/blacklist\nATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3744\", MODE=\"0666\", GROUP=\"plugdev\"\n\n# ST-Link/V2, the china adapter with the green plastic housing\nATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\", GROUP=\"plugdev\"\n\n\n\nFinally, it is time to (re-) connect the board. Now dmesg should show that\nthe mass storage device of the Discovery board is ignored:\n\n\n[  815.228928] usbcore: deregistering interface driver uas\n[  815.229201] usbcore: deregistering interface driver usb-storage\n[  823.001086] usb 1-3: new full-speed USB device number 7 using xhci_hcd\n[  823.374719] usb 1-3: New USB device found, idVendor=0483, idProduct=3744\n[  823.374724] usb 1-3: New USB device strings: Mfr=1, Product=2, SerialNumber=3\n[  823.374726] usb 1-3: Product: STM32 STLink\n[  823.374728] usb 1-3: Manufacturer: STMicroelectronics\n[  823.374730] usb 1-3: SerialNumber: W\\xffffffc3\\xffffffbf\\xffffffbfp\\x06reWW7\\x18\\x12g\n[  823.746878] usb-storage 1-3:1.0: USB Mass Storage device detected\n[  823.748299] usb-storage 1-3:1.0: device ignored\n[  823.748453] usbcore: registered new interface driver usb-storage\n[  823.771094] usbcore: registered new interface driver uas\n\n\n\nLet's read the preinstalled firmware of the STM8S105:\n\n\nstm8flash -cstlink \"-pstm8s105?6\" -r flash.img\n\n\n\nFurther reading\n\n\nAN3332\n:\nGenerating PWM signals using STM8S-DISCOVERY \n\n\nAN3259\n:\nRS232 communications with a terminal using the STM8S-DISCOVERY",
            "title": "STM8S105Discovery: Evaluation board made my ST"
        },
        {
            "location": "/hardware/stm8sdiscovery/#stm8s-discovery",
            "text": "A widespread evaluation board made by ST. All CPU pin are easily accessible\non 2x6 pin headers. It costs only $9 and includes a ST-Link/v1 flash\nprogrammer on board.  It should work now, but the support is very fresh and not thoroughly tested. \nAt least Blink.c is known to work already.  STM8S105C6T6 microcontroller, 32 KB Flash, 2 KB RAM, 1 KB EEPROM    LED on PD0, active low.  Touch button on PC1, PC2, PC3  external crystal 16MHz on PA1/PA2   The touch pins PC1 and PC3 (Arduino-Pin 24 and 26) are not connected to the\npin header on the board. To use them as I/O-pins you need to modify some\nsolder bridges (See STM8S-Discovery user manual).",
            "title": "STM8S Discovery"
        },
        {
            "location": "/hardware/stm8sdiscovery/#swim-connector",
            "text": "Pinout of CN7 SWIM connector     Pin  Signal      1  Vdd (3.3V)    2  SWIM    3  GND    4  NRST",
            "title": "SWIM connector"
        },
        {
            "location": "/hardware/stm8sdiscovery/#usage-with-linux-and-stm8flash",
            "text": "The discovery board implements two USB devices: A ST-LINK/V1 interface and a\n(not very useful) mass storage device with some links to the ST website. The\nimplementation of this mass storage device is very buggy and renders the\nhole board useless. You need to make modprobe to ignore it by adding this\nline to /etc/modprobe.conf or by adding a file\n/etc/modprobe.d/stdiscovery.conf with this line:  options usb-storage quirks=0483:3744:i  Unplug the Discovery board and unload the usb mass storage driver with  modprobe -r uas usb_storage  If you can't unload the usb_storage drive because it is in use with other\ndevices you can temporary trigger the same effect by this line:  echo \"0483:3744:i\" >/sys/module/usb_storage/parameters/quirks  The second step is to add a new udev rule in order to access the USB port.\nSave this as root in in  /etc/udev/rules.d/99-stlink.rules :  # ST-Link/V2 programming adapter\n\n# ST-Link V1, if using a STM8S discovery board\n# important: It needs a special entry in /etc/modprob/blacklist\nATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3744\", MODE=\"0666\", GROUP=\"plugdev\"\n\n# ST-Link/V2, the china adapter with the green plastic housing\nATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\", GROUP=\"plugdev\"  Finally, it is time to (re-) connect the board. Now dmesg should show that\nthe mass storage device of the Discovery board is ignored:  [  815.228928] usbcore: deregistering interface driver uas\n[  815.229201] usbcore: deregistering interface driver usb-storage\n[  823.001086] usb 1-3: new full-speed USB device number 7 using xhci_hcd\n[  823.374719] usb 1-3: New USB device found, idVendor=0483, idProduct=3744\n[  823.374724] usb 1-3: New USB device strings: Mfr=1, Product=2, SerialNumber=3\n[  823.374726] usb 1-3: Product: STM32 STLink\n[  823.374728] usb 1-3: Manufacturer: STMicroelectronics\n[  823.374730] usb 1-3: SerialNumber: W\\xffffffc3\\xffffffbf\\xffffffbfp\\x06reWW7\\x18\\x12g\n[  823.746878] usb-storage 1-3:1.0: USB Mass Storage device detected\n[  823.748299] usb-storage 1-3:1.0: device ignored\n[  823.748453] usbcore: registered new interface driver usb-storage\n[  823.771094] usbcore: registered new interface driver uas  Let's read the preinstalled firmware of the STM8S105:  stm8flash -cstlink \"-pstm8s105?6\" -r flash.img",
            "title": "Usage with Linux and stm8flash"
        },
        {
            "location": "/hardware/stm8sdiscovery/#further-reading",
            "text": "AN3332 :\nGenerating PWM signals using STM8S-DISCOVERY   AN3259 :\nRS232 communications with a terminal using the STM8S-DISCOVERY",
            "title": "Further reading"
        },
        {
            "location": "/about/",
            "text": "About\n\n\nThe idea is to smoothen the path towards your first successful STM8-based\nproject.\n\n\nThe Arduino project was very successful in offering a simplified API hiding\nmost of the complexity of embedded system programming while still allowing\nfor advanced programming technics.\n\n\nThe SPL (standard peripheral library) \noffered by\nST\n is very\npowerful and provides an relativly easy migration path towards the STM32 CPU\nseries in case a project outgrows the capabilities of the 8-bit STM8 series.\nBut using that library is not very intuitive and still requires a fairly\ndetailed knowledge of the CPU internals. \ncompiling the SPL with\nSDCC\n\n\nProject origin\n\n\nFor a customer I needed to port an existing project from an ATmega to a\nbetter suited (read: cheaper) platform. As the project was based on some\nArduino libraries, porting parts of the Arduino environment was the logical\nfirst step. After doing that porting the firmware was finished in a couple\nof days. Porting some of the more commonly used Arduino libraries was a fun\nproject done in my spare time later.\n\n\nAbout me\n\n\nI am a freelance programmer for embedded systems and electronics developer\nbased in Heidelberg, Germany. I work with embedded systems for more than\n25 years now.\n\n\nExperiences\n\n\ncurrent CPU architectures\n: AVR (ATmega, ATxmega), PIC, STM8, STM32, MCS51\n\n\nclassic CPU architectures\n: 6502, 68HC11, 6809, Z80, MCS48\n\n\nelectronics development\n: optical sensors, laser driver, sensor\nelectronics, measurement equipment, industrial control, SMPS, displays\n(LCD, TFT)",
            "title": "About"
        },
        {
            "location": "/about/#about",
            "text": "The idea is to smoothen the path towards your first successful STM8-based\nproject.  The Arduino project was very successful in offering a simplified API hiding\nmost of the complexity of embedded system programming while still allowing\nfor advanced programming technics.  The SPL (standard peripheral library)  offered by\nST  is very\npowerful and provides an relativly easy migration path towards the STM32 CPU\nseries in case a project outgrows the capabilities of the 8-bit STM8 series.\nBut using that library is not very intuitive and still requires a fairly\ndetailed knowledge of the CPU internals.  compiling the SPL with\nSDCC",
            "title": "About"
        },
        {
            "location": "/about/#project-origin",
            "text": "For a customer I needed to port an existing project from an ATmega to a\nbetter suited (read: cheaper) platform. As the project was based on some\nArduino libraries, porting parts of the Arduino environment was the logical\nfirst step. After doing that porting the firmware was finished in a couple\nof days. Porting some of the more commonly used Arduino libraries was a fun\nproject done in my spare time later.",
            "title": "Project origin"
        },
        {
            "location": "/about/#about-me",
            "text": "I am a freelance programmer for embedded systems and electronics developer\nbased in Heidelberg, Germany. I work with embedded systems for more than\n25 years now.  Experiences  current CPU architectures : AVR (ATmega, ATxmega), PIC, STM8, STM32, MCS51  classic CPU architectures : 6502, 68HC11, 6809, Z80, MCS48  electronics development : optical sensors, laser driver, sensor\nelectronics, measurement equipment, industrial control, SMPS, displays\n(LCD, TFT)",
            "title": "About me"
        }
    ]
}